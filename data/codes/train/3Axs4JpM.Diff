Index: binaries/data/mods/public/gui/gamesetup/gamesetup.js
===================================================================
--- binaries/data/mods/public/gui/gamesetup/gamesetup.js	(revision 16411)
+++ binaries/data/mods/public/gui/gamesetup/gamesetup.js	(working copy)
@@ -510,10 +510,14 @@
 
 	case "chat":
 		addChatMessage({ "type": "message", "guid": message.guid, "text": message.text });
 		break;
 
+	case "kicked":
+		addChatMessage({ "type": message.ban ? "banned" : "kicked", "username": message.username });
+		break;
+
 	// Singular client to host message
 	case "ready":
 		g_ReadyChanged -= 1;
 		if (g_ReadyChanged < 1 && g_PlayerAssignments[message.guid].player != -1)
 			addChatMessage({ "type": "ready", "guid": message.guid, "ready": +message.status == 1 });
@@ -1684,16 +1688,26 @@
 }
 
 function submitChatInput()
 {
 	var input = Engine.GetGUIObjectByName("chatInput");
-	var text = input.caption;
-	if (text.length)
+	var text = input.caption.trim();
+	input.caption = "";
+
+	if (!text.length)
+		return;
+
+	if (text.indexOf("/") == 0)
 	{
-		Engine.SendNetworkChat(text);
-		input.caption = "";
+		let kick = text.indexOf("/kick ") == 0;
+		let ban = text.indexOf("/ban ") == 0;
+		if (kick || ban)
+			Engine.KickPlayer(text.substr(text.indexOf(" ") + 1), ban);
+		return;
 	}
+
+	Engine.SendNetworkChat(text);
 }
 
 function addChatMessage(msg)
 {
 	var username = "";
@@ -1733,10 +1747,18 @@
 	case "disconnect":
 		var formattedUsername = '[color="'+ color +'"]' + username + '[/color]';
 		formatted = '[font="sans-bold-13"] ' + sprintf(translate("== %(message)s"), { message: sprintf(translate("%(username)s has left"), { username: formattedUsername }) }) + '[/font]';
 		break;
 
+	case "kicked":
+		formatted = '[font="sans-bold-13"] ' + sprintf(translate("== %(message)s"), { message: sprintf(translate("%(username)s has been kicked."), { username: username }) }) + '[/font]';
+		break;
+
+	case "banned":
+		formatted = '[font="sans-bold-13"] ' + sprintf(translate("== %(message)s"), { message: sprintf(translate("%(username)s has been banned."), { username: username }) }) + '[/font]';
+		break;
+		
 	case "message":
 		var formattedUsername = '[color="'+ color +'"]' + username + '[/color]';
 		var formattedUsernamePrefix = '[font="sans-bold-13"]' + sprintf(translate("<%(username)s>"), { username: formattedUsername }) + '[/font]'
 		formatted = sprintf(translate("%(username)s %(message)s"), { username: formattedUsernamePrefix, message: message });
 		break;
Index: binaries/data/mods/public/gui/gamesetup/gamesetup_mp.xml
===================================================================
--- binaries/data/mods/public/gui/gamesetup/gamesetup_mp.xml	(revision 16411)
+++ binaries/data/mods/public/gui/gamesetup/gamesetup_mp.xml	(working copy)
@@ -2,10 +2,11 @@
 
 <objects>
 
 	<script file="gui/common/network.js"/>
 	<script file="gui/common/functions_global_object.js"/>
+	<script file="gui/common/functions_utility.js"/>
 	<script file="gui/gamesetup/gamesetup_mp.js"/>
 
 	<!-- Add a translucent black background to fade out the menu page -->
 	<object type="image" sprite="ModernFade"/>
 
@@ -46,11 +47,11 @@
 			</object>
 
 			<object hotkey="confirm" type="button" size="50%+5 100%-45 100%-18 100%-17" style="ModernButtonRed">
 				<translatableAttribute id="caption">Continue</translatableAttribute>
 				<action on="Press">
-					var joinPlayerName = Engine.GetGUIObjectByName("joinPlayerName").caption;
+					var joinPlayerName = sanitizePlayerName(Engine.GetGUIObjectByName("joinPlayerName").caption, true, true);
 					var joinServer = Engine.GetGUIObjectByName("joinServer").caption;
 					if (startJoin(joinPlayerName, joinServer))
 						switchSetupPage("pageJoin", "pageConnecting");
 				</action>
 			</object>
@@ -88,11 +89,11 @@
 			</object>
 
 			<object type="button" size="50%+5 100%-45 100%-18 100%-17" style="ModernButtonRed">
 				<translatableAttribute id="caption">Continue</translatableAttribute>
 				<action on="Press">
-					var hostPlayerName = Engine.GetGUIObjectByName("hostPlayerName").caption;
+					var hostPlayerName = sanitizePlayerName(Engine.GetGUIObjectByName("hostPlayerName").caption, true, true);
 					var hostServerName = Engine.GetGUIObjectByName("hostServerName").caption;
 					if (startHost(hostPlayerName, hostServerName))
 						switchSetupPage("pageHost", "pageConnecting");
 				</action>
 			</object>
Index: binaries/data/mods/public/gui/options/options.js
===================================================================
--- binaries/data/mods/public/gui/options/options.js	(revision 16411)
+++ binaries/data/mods/public/gui/options/options.js	(working copy)
@@ -30,10 +30,11 @@
 		[translate("Real Water Depth"), translate("Use actual water depth in rendering calculations"), {"renderer":"WaterRealDepth", "config":"waterrealdepth"}, "boolean"],
 		[translate("Water Reflections"), translate("Allow water to reflect a mirror image"), {"renderer":"WaterReflection", "config":"waterreflection"}, "boolean"],
 		[translate("Water Refraction"), translate("Use a real water refraction map and not transparency"), {"renderer":"WaterRefraction", "config":"waterrefraction"}, "boolean"],
 		[translate("Shadows on Water"), translate("Cast shadows on water"), {"renderer":"WaterShadows", "config":"watershadows"}, "boolean"],
 		[translate("VSync"), translate("Run vertical sync to fix screen tearing. REQUIRES GAME RESTART"), {"config":"vsync"}, "boolean"],
+		[translate("Limit FPS in Menus"), translate("Limit frames per second in all menus."), {"config":"gui.menu.limit_fps"}, "boolean"],
 	],
 	"soundSetting":
 	[
 		[translate("Master Gain"), translate("Master audio gain"), {"config":"sound.mastergain", "function":"Engine.SetMasterGain(Number(this.caption));"}, "number"],
 		[translate("Music Gain"), translate("In game music gain"), {"config":"sound.musicgain", "function":"Engine.SetMusicGain(Number(this.caption));"}, "number"],
Index: binaries/data/mods/public/gui/session/input.js
===================================================================
--- binaries/data/mods/public/gui/session/input.js	(revision 16411)
+++ binaries/data/mods/public/gui/session/input.js	(working copy)
@@ -157,11 +157,11 @@
 	else if (placementSupport.mode === "wall")
 	{
 		if (placementSupport.wallSet && placementSupport.position)
 		{
 			// Fetch an updated list of snapping candidate entities
-			placementSupport.wallSnapEntities = Engine.PickSimilarFriendlyEntities(
+			placementSupport.wallSnapEntities = Engine.PickSimilarPlayerEntities(
 				placementSupport.wallSet.templates.tower,
 				placementSupport.wallSnapEntitiesIncludeOffscreen,
 				true, // require exact template match
 				true  // include foundations
 			);
@@ -547,11 +547,11 @@
 		switch (ev.type)
 		{
 		case "mousemotion":
 			var rect = updateBandbox(bandbox, ev, false);
 
-			var ents = Engine.PickFriendlyEntitiesInRect(rect[0], rect[1], rect[2], rect[3], Engine.GetPlayerID());
+			var ents = Engine.PickPlayerEntitiesInRect(rect[0], rect[1], rect[2], rect[3], Engine.GetPlayerID());
 			var preferredEntities = getPreferredEntities(ents);
 			g_Selection.setHighlightList(preferredEntities);
 
 			return false;
 
@@ -559,11 +559,11 @@
 			if (ev.button == SDL_BUTTON_LEFT)
 			{
 				var rect = updateBandbox(bandbox, ev, true);
 
 				// Get list of entities limited to preferred entities
-				var ents = getPreferredEntities(Engine.PickFriendlyEntitiesInRect(rect[0], rect[1], rect[2], rect[3], Engine.GetPlayerID()));
+				var ents = getPreferredEntities(Engine.PickPlayerEntitiesInRect(rect[0], rect[1], rect[2], rect[3], Engine.GetPlayerID()));
 
 				// Remove the bandbox hover highlighting
 				g_Selection.setHighlightList([]);
 
 				// Update the list of selected units
@@ -1041,11 +1041,11 @@
 						// Select units matching exact template name (same rank)
 						templateToMatch = GetEntityState(selectedEntity).template;
 					}
 
 					// TODO: Should we handle "control all units" here as well?
-					ents = Engine.PickSimilarFriendlyEntities(templateToMatch, showOffscreen, matchRank, false);
+					ents = Engine.PickSimilarPlayerEntities(templateToMatch, showOffscreen, matchRank, false);
 				}
 				else
 				{
 					// It's single click right now but it may become double or triple click
 					doubleClicked = false;
Index: binaries/data/mods/public/gui/session/messages.js
===================================================================
--- binaries/data/mods/public/gui/session/messages.js	(revision 16411)
+++ binaries/data/mods/public/gui/session/messages.js	(working copy)
@@ -236,11 +236,13 @@
 			obj.caption = translate("Connection to the server has been authenticated.");
 			obj.hidden = false;
 			break;
 		case "disconnected":
 			g_Disconnected = true;
-			obj.caption = translate("Connection to the server has been lost.") + "\n\n" + translate("The game has ended.");
+			obj.caption = translate("Connection to the server has been lost.") + "\n" +
+				sprintf(translate("Reason: %(reason)s."), { reason: getDisconnectReason(message.reason) }) + "\n" +
+				translate("The game has ended.");
 			obj.hidden = false;
 			break;
 		default:
 			error("Unrecognised netstatus type '" + message.status + "'");
 			break;
@@ -314,14 +316,16 @@
 }
 
 function submitChatInput()
 {
 	var input = Engine.GetGUIObjectByName("chatInput");
-	var text = input.caption;
+	var text = input.caption.trim();
 	var isCheat = false;
+	
 	if (text.length)
 	{
+		// Parse cheats
 		if (!g_IsObserver && g_Players[Engine.GetPlayerID()].cheatsEnabled)
 		{
 			for each (var cheat in Object.keys(cheats))
 			{
 				// Line must start with the cheat.
@@ -365,12 +369,25 @@
 				isCheat = true;
 				break;
 			}
 		}
 
+		// Parse direct commands
+		if (text.indexOf("/") == 0)
+		{
+			if (text == "/list")
+				addChatMessage({ "type": "clientlist", "guid": "local"});
+			else
+			{
+				let kick = text.indexOf("/kick ") == 0;
+				let ban = text.indexOf("/ban ") == 0;
+				if (kick || ban)
+					Engine.KickPlayer(text.substr(text.indexOf(" ") + 1), ban);
+			}
+		}
 		// Observers should only send messages to "/all"
-		if (!isCheat && (!g_IsObserver || text.indexOf("/") == -1 || text.indexOf("/all ") == 0))
+		else if (!isCheat && (!g_IsObserver || text.indexOf("/") == -1 || text.indexOf("/all ") == 0))
 		{
 			if (Engine.GetGUIObjectByName("toggleTeamChat").checked)
 				text = "/team " + text;
 
 			if (g_IsNetworked)
Index: binaries/data/mods/public/gui/session/minimap_panel.xml
===================================================================
--- binaries/data/mods/public/gui/session/minimap_panel.xml	(revision 16411)
+++ binaries/data/mods/public/gui/session/minimap_panel.xml	(working copy)
@@ -11,11 +11,11 @@
 		<object type="button"
 			tooltip_style="sessionToolTip"
 			hotkey="selection.idleworker"
 		>
 			<translatableAttribute id="tooltip">Find idle worker</translatableAttribute>
-			<action on="Press">findIdleUnit(["Female", "Trade", "FishingBoat", "CitizenSoldier", "Healer"]);</action>
+			<action on="Press">findIdleUnit(["Female", "Trader", "FishingBoat", "CitizenSoldier", "Healer"]);</action>
 			<action on="MouseEnter">Engine.GetGUIObjectByName("idleOverlay").sprite = "stretched:session/minimap-idle-highlight.png";</action>
 			<action on="MouseLeave">Engine.GetGUIObjectByName("idleOverlay").sprite = "stretched:session/minimap-idle.png";</action>
 			<action on="MouseLeftPress">Engine.GetGUIObjectByName("idleOverlay").sprite = "stretched:session/minimap-idle.png";</action>
 			<action on="MouseLeftRelease">Engine.GetGUIObjectByName("idleOverlay").sprite = "stretched:session/minimap-idle-highlight.png";</action>
 		</object>
Index: binaries/data/mods/public/gui/session/session.js
===================================================================
--- binaries/data/mods/public/gui/session/session.js	(revision 16411)
+++ binaries/data/mods/public/gui/session/session.js	(working copy)
@@ -546,10 +546,20 @@
 		if (battleState)
 			global.music.setState(global.music.states[battleState]);
 	}
 }
 
+function onReplayFinished()
+{
+	closeMenu();
+	closeOpenDialogs();
+	pauseGame();
+	var btCaptions = [translateWithContext("replayFinished", "Yes"), translateWithContext("replayFinished", "No")];
+	var btCode = [leaveGame, resumeGame];
+	messageBox(400, 200, translateWithContext("replayFinished", "The replay has finished. Do you want to quit?"), translateWithContext("replayFinished","Confirmation"), 0, btCaptions, btCode);
+}
+
 /**
 * updates a status bar on the GUI
 * nameOfBar: name of the bar
 * points: points to show
 * maxPoints: max points 
@@ -706,11 +716,13 @@
 	Engine.GetGUIObjectByName("resourceFood").caption = Math.floor(playerState.resourceCounts.food);
 	Engine.GetGUIObjectByName("resourceWood").caption = Math.floor(playerState.resourceCounts.wood);
 	Engine.GetGUIObjectByName("resourceStone").caption = Math.floor(playerState.resourceCounts.stone);
 	Engine.GetGUIObjectByName("resourceMetal").caption = Math.floor(playerState.resourceCounts.metal);
 	Engine.GetGUIObjectByName("resourcePop").caption = playerState.popCount + "/" + playerState.popLimit;
-
+	Engine.GetGUIObjectByName("population").tooltip = translate("Population (current / limit)") + "\n"
+					+ sprintf(translate("Maximum population: %(popCap)s"), { "popCap": playerState.popMax });
+	 
 	g_IsTrainingBlocked = playerState.trainingBlocked;
 }
 
 function selectAndMoveTo(ent)
 {
@@ -785,26 +797,23 @@
 
 // Toggles the display of status bars for all of the player's entities.
 function recalculateStatusBarDisplay()
 {
 	if (g_ShowAllStatusBars)
-		var entities = Engine.PickFriendlyEntitiesOnScreen(Engine.GetPlayerID());
+		var entities = g_IsObserver ? Engine.PickAllPlayersEntitiesOnScreen() : Engine.PickPlayerEntitiesOnScreen(Engine.GetPlayerID());
 	else
 	{
 		var selected = g_Selection.toList();
 		for each (var ent in g_Selection.highlighted)
 			selected.push(ent);
-
+		
 		// Remove selected entities from the 'all entities' array, to avoid disabling their status bars.
-		var entities = Engine.GuiInterfaceCall("GetPlayerEntities").filter(
-				function(idx) { return (selected.indexOf(idx) == -1); }
-		);
+		var entities = Engine.GuiInterfaceCall(g_IsObserver ? "GetAllPlayerEntities" : "GetPlayerEntities").filter(idx => selected.indexOf(idx) == -1);
 	}
 
 	Engine.GuiInterfaceCall("SetStatusBars", { "entities": entities, "enabled": g_ShowAllStatusBars });
 }
-
 // Update the additional list of entities to be highlighted.
 function updateAdditionalHighlight()
 {
 	var entsAdd = [];    // list of entities units to be highlighted
 	var entsRemove = [];
Index: binaries/data/mods/public/gui/session/session.xml
===================================================================
--- binaries/data/mods/public/gui/session/session.xml	(revision 16411)
+++ binaries/data/mods/public/gui/session/session.xml	(working copy)
@@ -5,10 +5,11 @@
 <script file="gui/common/colorFades.js"/>
 <script file="gui/common/functions_civinfo.js"/>
 <script file="gui/common/functions_global_object.js"/>
 <script file="gui/common/functions_utility.js"/>
 <script file="gui/common/l10n.js"/>
+<script file="gui/common/network.js"/>
 <script file="gui/common/music.js"/>
 <script file="gui/common/timer.js"/>
 <script file="gui/common/tooltips.js"/>
 <!-- load all scripts in this directory -->
 <script directory="gui/session/"/>
@@ -20,10 +21,14 @@
 
 	<action on="SimulationUpdate">
 		onSimulationUpdate();
 	</action>
 
+	<action on="ReplayFinished">
+		onReplayFinished();
+	</action>
+
 	<action on="Press">
 		this.hidden = !this.hidden;
 	</action>
 
 	<!-- ================================  ================================ -->
Index: binaries/data/mods/public/gui/session/top_panel/resource_population.xml
===================================================================
--- binaries/data/mods/public/gui/session/top_panel/resource_population.xml	(revision 16411)
+++ binaries/data/mods/public/gui/session/top_panel/resource_population.xml	(working copy)
@@ -1,6 +1,5 @@
 <?xml version="1.0" encoding="utf-8"?>
 <object name="population" size="370 0 460 100%" type="image" style="resourceCounter" tooltip_style="sessionToolTipBold">
-	<translatableAttribute id="tooltip">Population (current / limit)</translatableAttribute>
 	<object size="0 -4 40 34" type="image" sprite="stretched:session/icons/resources/population.png" ghost="true"/>
 	<object size="32 0 100% 100%-2" type="text" style="resourceText" name="resourcePop"/>
 </object>
Index: binaries/data/mods/public/simulation/components/GuiInterface.js
===================================================================
--- binaries/data/mods/public/simulation/components/GuiInterface.js	(revision 16411)
+++ binaries/data/mods/public/simulation/components/GuiInterface.js	(working copy)
@@ -857,10 +857,16 @@
 {
 	var cmpRangeManager = Engine.QueryInterface(SYSTEM_ENTITY, IID_RangeManager);
 	return cmpRangeManager.GetEntitiesByPlayer(player);
 };
 
+GuiInterface.prototype.GetAllPlayerEntities = function(player)
+{
+	var cmpRangeManager = Engine.QueryInterface(SYSTEM_ENTITY, IID_RangeManager);
+	return cmpRangeManager.GetAllPlayerEntities(player);
+};
+
 /**
  * Displays the rally points of a given list of entities (carried in cmd.entities).
  * 
  * The 'cmd' object may carry its own x/z coordinate pair indicating the location where the rally point should 
  * be rendered, in order to support instantaneously rendering a rally point marker at a specified location 
@@ -1831,10 +1837,11 @@
 
 	"SetSelectionHighlight": 1,
 	"GetAllBuildableEntities": 1,
 	"SetStatusBars": 1,
 	"GetPlayerEntities": 1,
+	"GetAllPlayerEntities": 1,
 	"DisplayRallyPoint": 1,
 	"SetBuildingPlacementPreview": 1,
 	"SetWallPlacementPreview": 1,
 	"GetFoundationSnapData": 1,
 	"PlaySound": 1,
Index: source/gui/scripting/ScriptFunctions.cpp
===================================================================
--- source/gui/scripting/ScriptFunctions.cpp	(revision 16411)
+++ source/gui/scripting/ScriptFunctions.cpp	(working copy)
@@ -60,10 +60,11 @@
 #include "renderer/scripting/JSInterface_Renderer.h"
 #include "simulation2/Simulation2.h"
 #include "simulation2/components/ICmpAIManager.h"
 #include "simulation2/components/ICmpCommandQueue.h"
 #include "simulation2/components/ICmpGuiInterface.h"
+#include "simulation2/components/ICmpPlayerManager.h"
 #include "simulation2/components/ICmpRangeManager.h"
 #include "simulation2/components/ICmpSelectable.h"
 #include "simulation2/components/ICmpTemplateManager.h"
 #include "simulation2/helpers/Selection.h"
 #include "soundmanager/SoundManager.h"
@@ -152,21 +153,39 @@
 entity_id_t PickEntityAtPoint(ScriptInterface::CxPrivate* UNUSED(pCxPrivate), int x, int y)
 {
 	return EntitySelection::PickEntityAtPoint(*g_Game->GetSimulation2(), *g_Game->GetView()->GetCamera(), x, y, g_Game->GetPlayerID(), false);
 }
 
-std::vector<entity_id_t> PickFriendlyEntitiesInRect(ScriptInterface::CxPrivate* UNUSED(pCxPrivate), int x0, int y0, int x1, int y1, int player)
+std::vector<entity_id_t> PickPlayerEntitiesInRect(ScriptInterface::CxPrivate* UNUSED(pCxPrivate), int x0, int y0, int x1, int y1, int player)
 {
 	return EntitySelection::PickEntitiesInRect(*g_Game->GetSimulation2(), *g_Game->GetView()->GetCamera(), x0, y0, x1, y1, player, false);
 }
 
-std::vector<entity_id_t> PickFriendlyEntitiesOnScreen(ScriptInterface::CxPrivate* pCxPrivate, int player)
+std::vector<entity_id_t> PickPlayerEntitiesOnScreen(ScriptInterface::CxPrivate* pCxPrivate, int player)
 {
-	return PickFriendlyEntitiesInRect(pCxPrivate, 0, 0, g_xres, g_yres, player);
+	return PickPlayerEntitiesInRect(pCxPrivate, 0, 0, g_xres, g_yres, player);
 }
 
-std::vector<entity_id_t> PickSimilarFriendlyEntities(ScriptInterface::CxPrivate* UNUSED(pCxPrivate), std::string templateName, bool includeOffScreen, bool matchRank, bool allowFoundations)
+std::vector<entity_id_t> PickAllPlayersEntitiesOnScreen(ScriptInterface::CxPrivate* pCxPrivate)
+{
+	std::vector<entity_id_t> entities;
+
+	CmpPtr<ICmpPlayerManager> cmpPlayerManager(*g_Game->GetSimulation2(), SYSTEM_ENTITY);
+
+	if (!cmpPlayerManager)
+		return entities;
+
+	i32 numPlayers = cmpPlayerManager->GetNumPlayers();
+	for (i32 player = 1; player < numPlayers; ++player)
+	{
+		std::vector<entity_id_t> ents = PickPlayerEntitiesOnScreen(pCxPrivate, player);
+		entities.insert(entities.end(), ents.begin(), ents.end());
+	}
+	return entities;
+}
+
+std::vector<entity_id_t> PickSimilarPlayerEntities(ScriptInterface::CxPrivate* UNUSED(pCxPrivate), std::string templateName, bool includeOffScreen, bool matchRank, bool allowFoundations)
 {
 	return EntitySelection::PickSimilarEntities(*g_Game->GetSimulation2(), *g_Game->GetView()->GetCamera(), templateName, g_Game->GetPlayerID(), includeOffScreen, matchRank, false, allowFoundations);
 }
 
 CFixedVector3D GetTerrainAtScreenPoint(ScriptInterface::CxPrivate* UNUSED(pCxPrivate), int x, int y)
@@ -346,10 +365,16 @@
 	SAFE_DELETE(g_NetServer);
 	SAFE_DELETE(g_NetClient);
 	SAFE_DELETE(g_Game);
 }
 
+void KickPlayer(ScriptInterface::CxPrivate* UNUSED(pCxPrivate), CStrW playerName, bool ban)
+{
+	if (g_NetServer)
+		g_NetServer->KickPlayer(playerName, ban);
+}
+
 JS::Value PollNetworkClient(ScriptInterface::CxPrivate* pCxPrivate)
 {
 	if (!g_NetClient)
 		return JS::UndefinedValue();
 
@@ -931,22 +956,24 @@
 	scriptInterface.RegisterFunction<JS::Value, std::wstring, JS::HandleValue, &GuiInterfaceCall>("GuiInterfaceCall");
 	scriptInterface.RegisterFunction<void, JS::HandleValue, &PostNetworkCommand>("PostNetworkCommand");
 
 	// Entity picking
 	scriptInterface.RegisterFunction<entity_id_t, int, int, &PickEntityAtPoint>("PickEntityAtPoint");
-	scriptInterface.RegisterFunction<std::vector<entity_id_t>, int, int, int, int, int, &PickFriendlyEntitiesInRect>("PickFriendlyEntitiesInRect");
-	scriptInterface.RegisterFunction<std::vector<entity_id_t>, int, &PickFriendlyEntitiesOnScreen>("PickFriendlyEntitiesOnScreen");
-	scriptInterface.RegisterFunction<std::vector<entity_id_t>, std::string, bool, bool, bool, &PickSimilarFriendlyEntities>("PickSimilarFriendlyEntities");
+	scriptInterface.RegisterFunction<std::vector<entity_id_t>, int, int, int, int, int, &PickPlayerEntitiesInRect>("PickPlayerEntitiesInRect");
+	scriptInterface.RegisterFunction<std::vector<entity_id_t>, int, &PickPlayerEntitiesOnScreen>("PickPlayerEntitiesOnScreen");
+	scriptInterface.RegisterFunction<std::vector<entity_id_t>, &PickAllPlayersEntitiesOnScreen>("PickAllPlayersEntitiesOnScreen");
+	scriptInterface.RegisterFunction<std::vector<entity_id_t>, std::string, bool, bool, bool, &PickSimilarPlayerEntities>("PickSimilarPlayerEntities");
 	scriptInterface.RegisterFunction<CFixedVector3D, int, int, &GetTerrainAtScreenPoint>("GetTerrainAtScreenPoint");
 
 	// Network / game setup functions
 	scriptInterface.RegisterFunction<void, &StartNetworkGame>("StartNetworkGame");
 	scriptInterface.RegisterFunction<void, JS::HandleValue, int, &StartGame>("StartGame");
 	scriptInterface.RegisterFunction<void, &Script_EndGame>("EndGame");
 	scriptInterface.RegisterFunction<void, std::wstring, &StartNetworkHost>("StartNetworkHost");
 	scriptInterface.RegisterFunction<void, std::wstring, std::string, &StartNetworkJoin>("StartNetworkJoin");
 	scriptInterface.RegisterFunction<void, &DisconnectNetworkGame>("DisconnectNetworkGame");
+	scriptInterface.RegisterFunction<void, CStrW, bool, &KickPlayer>("KickPlayer");
 	scriptInterface.RegisterFunction<JS::Value, &PollNetworkClient>("PollNetworkClient");
 	scriptInterface.RegisterFunction<void, JS::HandleValue, &SetNetworkGameAttributes>("SetNetworkGameAttributes");
 	scriptInterface.RegisterFunction<void, int, std::string, &AssignNetworkPlayer>("AssignNetworkPlayer");
 	scriptInterface.RegisterFunction<void, std::string, int, &SetNetworkPlayerStatus>("SetNetworkPlayerStatus");
 	scriptInterface.RegisterFunction<void, &ClearAllPlayerReady>("ClearAllPlayerReady");
Index: source/main.cpp
===================================================================
--- source/main.cpp	(revision 16411)
+++ source/main.cpp	(working copy)
@@ -41,10 +41,11 @@
 #include "lib/external_libraries/libsdl.h"
 
 #include "ps/ArchiveBuilder.h"
 #include "ps/CConsole.h"
 #include "ps/CLogger.h"
+#include "ps/ConfigDB.h"
 #include "ps/Filesystem.h"
 #include "ps/Game.h"
 #include "ps/Globals.h"
 #include "ps/Hotkey.h"
 #include "ps/Loader.h"
@@ -303,13 +304,18 @@
 		need_update = false;
 		// don't use SDL_WaitEvent: don't want the main loop to freeze until app focus is restored
 		SDL_Delay(10);
 	}
 
-	// TODO: throttling: limit update and render frequency to the minimum.
+	// Throttling: limit update and render frequency to the minimum.
 	// this is mostly relevant for "inactive" state, so that other windows
 	// get enough CPU time, but it's always nice for power+thermal management.
+	const float maxFPSMenu = 50.0;
+	bool limit_fps = false;
+	CFG_GET_VAL("gui.menu.limit_fps", limit_fps);
+	if (limit_fps && (!g_Game || !g_Game->IsGameStarted()))
+		SDL_Delay((1000.0 / maxFPSMenu) - realTimeSinceLastFrame);
 
 
 	// this scans for changed files/directories and reloads them, thus
 	// allowing hotloading (changes are immediately assimilated in-game).
 	ReloadChangedFiles();
@@ -445,26 +451,45 @@
 		return;
 
 	// run non-visual simulation replay if requested
 	if (args.Has("replay"))
 	{
+		std::string replayFile = args.Get("replay");
+		if (!FileExists(OsPath(replayFile)))
+		{
+			debug_printf("ERROR: The requested replay file '%s' does not exist!\n", replayFile.c_str());
+			return;
+		}
+
 		Paths paths(args);
 		g_VFS = CreateVfs(20 * MiB);
 		g_VFS->Mount(L"cache/", paths.Cache(), VFS_MOUNT_ARCHIVABLE);
 		MountMods(paths, GetMods(args, INIT_MODS));
 
 		{
 			CReplayPlayer replay;
-			replay.Load(args.Get("replay"));
-			replay.Replay(args.Has("serializationtest"));
+			replay.Load(replayFile);
+			replay.Replay(args.Has("serializationtest"), args.Has("ooslog"));
 		}
 
 		g_VFS.reset();
 
 		CXeromyces::Terminate();
 		return;
 	}
+ 
+	// If visual replay file does not exist, quit before starting the renderer
+	if (args.Has("replay-visual"))
+	{
+		std::string replayFile = args.Get("replay-visual");
+		if (!FileExists(OsPath(replayFile)))
+		{
+			debug_printf("ERROR: The requested replay file '%s' does not exist!\n", replayFile.c_str());
+			return;
+		}
+	}
+
 
 	// run in archive-building mode if requested
 	if (args.Has("archivebuild"))
 	{
 		Paths paths(args);
Index: source/network/NetClient.cpp
===================================================================
--- source/network/NetClient.cpp	(revision 16411)
+++ source/network/NetClient.cpp	(working copy)
@@ -91,10 +91,11 @@
 
 	AddTransition(NCS_PREGAME, (uint)NMT_CHAT, NCS_PREGAME, (void*)&OnChat, context);
 	AddTransition(NCS_PREGAME, (uint)NMT_READY, NCS_PREGAME, (void*)&OnReady, context);
 	AddTransition(NCS_PREGAME, (uint)NMT_GAME_SETUP, NCS_PREGAME, (void*)&OnGameSetup, context);
 	AddTransition(NCS_PREGAME, (uint)NMT_PLAYER_ASSIGNMENT, NCS_PREGAME, (void*)&OnPlayerAssignment, context);
+	AddTransition(NCS_PREGAME, (uint)NMT_KICKED, NCS_PREGAME, (void*)&OnKicked, context);
 	AddTransition(NCS_PREGAME, (uint)NMT_GAME_START, NCS_LOADING, (void*)&OnGameStart, context);
 	AddTransition(NCS_PREGAME, (uint)NMT_JOIN_SYNC_START, NCS_JOIN_SYNCING, (void*)&OnJoinSyncStart, context);
 
 	AddTransition(NCS_JOIN_SYNCING, (uint)NMT_CHAT, NCS_JOIN_SYNCING, (void*)&OnChat, context);
 	AddTransition(NCS_JOIN_SYNCING, (uint)NMT_GAME_SETUP, NCS_JOIN_SYNCING, (void*)&OnGameSetup, context);
@@ -107,10 +108,11 @@
 	AddTransition(NCS_LOADING, (uint)NMT_CHAT, NCS_LOADING, (void*)&OnChat, context);
 	AddTransition(NCS_LOADING, (uint)NMT_GAME_SETUP, NCS_LOADING, (void*)&OnGameSetup, context);
 	AddTransition(NCS_LOADING, (uint)NMT_PLAYER_ASSIGNMENT, NCS_LOADING, (void*)&OnPlayerAssignment, context);
 	AddTransition(NCS_LOADING, (uint)NMT_LOADED_GAME, NCS_INGAME, (void*)&OnLoadedGame, context);
 
+	AddTransition(NCS_INGAME, (uint)NMT_KICKED, NCS_INGAME, (void*)&OnKicked, context);
 	AddTransition(NCS_INGAME, (uint)NMT_CHAT, NCS_INGAME, (void*)&OnChat, context);
 	AddTransition(NCS_INGAME, (uint)NMT_GAME_SETUP, NCS_INGAME, (void*)&OnGameSetup, context);
 	AddTransition(NCS_INGAME, (uint)NMT_PLAYER_ASSIGNMENT, NCS_INGAME, (void*)&OnPlayerAssignment, context);
 	AddTransition(NCS_INGAME, (uint)NMT_SIMULATION_COMMAND, NCS_INGAME, (void*)&OnInGame, context);
 	AddTransition(NCS_INGAME, (uint)NMT_SYNC_ERROR, NCS_INGAME, (void*)&OnInGame, context);
@@ -582,10 +584,27 @@
 	client->m_ClientTurnManager->UpdateFastForward();
 
 	return true;
 }
 
+bool CNetClient::OnKicked(void *context, CFsmEvent* event)
+{
+	ENSURE(event->GetType() == (uint)NMT_KICKED);
+
+	CNetClient* client = (CNetClient*)context;
+	JSContext* cx = client->GetScriptInterface().GetContext();
+
+	CKickedMessage* message = (CKickedMessage*)event->GetParamRef();
+	JS::RootedValue msg(cx);
+	client->GetScriptInterface().Eval("({'type':'kicked'})", &msg);
+	client->GetScriptInterface().SetProperty(msg, "username", message->m_Name, false);
+	client->GetScriptInterface().SetProperty(msg, "ban", message->m_Ban, false);
+	client->PushGuiMessage(msg);
+
+	return true;
+}
+
 bool CNetClient::OnLoadedGame(void* context, CFsmEvent* event)
 {
 	ENSURE(event->GetType() == (uint)NMT_LOADED_GAME);
 
 	CNetClient* client = (CNetClient*)context;
Index: source/network/NetClient.h
===================================================================
--- source/network/NetClient.h	(revision 16411)
+++ source/network/NetClient.h	(working copy)
@@ -193,11 +193,11 @@
 	static bool OnInGame(void* context, CFsmEvent* event);
 	static bool OnGameStart(void* context, CFsmEvent* event);
 	static bool OnJoinSyncStart(void* context, CFsmEvent* event);
 	static bool OnJoinSyncEndCommandBatch(void* context, CFsmEvent* event);
 	static bool OnLoadedGame(void* context, CFsmEvent* event);
-
+	static bool OnKicked(void* context, CFsmEvent* event);
 	/**
 	 * Take ownership of a session object, and use it for all network communication.
 	 */
 	void SetAndOwnSession(CNetClientSession* session);
 
Index: source/network/NetHost.h
===================================================================
--- source/network/NetHost.h	(revision 16411)
+++ source/network/NetHost.h	(working copy)
@@ -1,6 +1,6 @@
-/* Copyright (C) 2011 Wildfire Games.
+/* Copyright (C) 2015 Wildfire Games.
  * This file is part of 0 A.D.
  *
  * 0 A.D. is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 2 of the License, or
@@ -60,11 +60,13 @@
 enum NetDisconnectReason
 {
 	NDR_UNKNOWN = 0,
 	NDR_UNEXPECTED_SHUTDOWN,
 	NDR_INCORRECT_PROTOCOL_VERSION,
-	NDR_SERVER_ALREADY_IN_GAME
+	NDR_SERVER_ALREADY_IN_GAME,
+	NDR_KICKED,
+	NDR_BANNED
 };
 
 class CNetHost
 {
 public:
Index: source/network/NetMessage.cpp
===================================================================
--- source/network/NetMessage.cpp	(revision 16411)
+++ source/network/NetMessage.cpp	(working copy)
@@ -133,10 +133,14 @@
 
 	case NMT_LOADED_GAME:
 		pNewMessage = new CLoadedGameMessage;
 		break;
 
+	case NMT_KICKED:
+		pNewMessage = new CKickedMessage;
+		break;
+
 	case NMT_SERVER_HANDSHAKE:
 		pNewMessage = new CSrvHandshakeMessage;
 		break;
 
 	case NMT_SERVER_HANDSHAKE_RESPONSE:
Index: source/network/NetMessages.h
===================================================================
--- source/network/NetMessages.h	(revision 16411)
+++ source/network/NetMessages.h	(working copy)
@@ -61,11 +61,12 @@
 	NMT_GAME_START,
 	NMT_END_COMMAND_BATCH,
 	NMT_SYNC_CHECK,	// OOS-detection hash checking
 	NMT_SYNC_ERROR,	// OOS-detection error
 	NMT_SIMULATION_COMMAND,
-	NMT_LAST				// Last message in the list
+	NMT_LAST,				// Last message in the list
+	NMT_KICKED
 };
 
 // Authentication result codes
 enum AuthenticateResultCode
 {
@@ -135,10 +136,15 @@
 
 START_NMT_CLASS_(FileTransferRequest, NMT_FILE_TRANSFER_REQUEST)
 	NMT_FIELD_INT(m_RequestID, u32, 4)
 END_NMT_CLASS()
 
+START_NMT_CLASS_(Kicked, NMT_KICKED)
+	NMT_FIELD(CStrW, m_Name)
+	NMT_FIELD_INT(m_Ban, bool, 1)
+END_NMT_CLASS()
+
 START_NMT_CLASS_(FileTransferResponse, NMT_FILE_TRANSFER_RESPONSE)
 	NMT_FIELD_INT(m_RequestID, u32, 4)
 	NMT_FIELD_INT(m_Length, u32, 4)
 END_NMT_CLASS()
 
Index: source/network/NetServer.cpp
===================================================================
--- source/network/NetServer.cpp	(revision 16411)
+++ source/network/NetServer.cpp	(working copy)
@@ -119,11 +119,11 @@
 
 CNetServerWorker::CNetServerWorker(int autostartPlayers) :
 	m_AutostartPlayers(autostartPlayers),
 	m_Shutdown(false),
 	m_ScriptInterface(NULL),
-	m_NextHostID(1), m_Host(NULL), m_Stats(NULL)
+	m_NextHostID(1), m_Host(NULL), m_HostGUID(), m_Stats(NULL)
 {
 	m_State = SERVER_STATE_UNCONNECTED;
 
 	m_ServerTurnManager = NULL;
 
@@ -603,10 +603,20 @@
 	session->SetFirstState(NSS_HANDSHAKE);
 }
 
 bool CNetServerWorker::HandleConnect(CNetServerSession* session)
 {
+	CNetServerWorker& server = session->GetServer();
+
+	// Disconnect banned IPs
+	if (std::find(server.m_BannedIPs.begin(), server.m_BannedIPs.end(), session->GetIPAddress()) != server.m_BannedIPs.end())
+	{
+		session->Disconnect(NDR_UNKNOWN);
+		return false;
+	}
+
+	// Send handshake challenge
 	CSrvHandshakeMessage handshake;
 	handshake.m_Magic = PS_PROTOCOL_MAGIC;
 	handshake.m_ProtocolVersion = PS_PROTOCOL_VERSION;
 	handshake.m_SoftwareVersion = PS_PROTOCOL_VERSION;
 	return session->SendMessage(&handshake);
@@ -614,10 +624,13 @@
 
 void CNetServerWorker::OnUserJoin(CNetServerSession* session)
 {
 	AddPlayer(session->GetGUID(), session->GetUserName());
 
+	if (m_HostGUID.empty())
+		m_HostGUID = session->GetGUID();
+
 	CGameSetupMessage gameSetupMessage(GetScriptInterface());
 	gameSetupMessage.m_Data = m_GameAttributes.get();
 	session->SendMessage(&gameSetupMessage);
 
 	CPlayerAssignmentMessage assignMessage;
@@ -629,13 +642,10 @@
 {
 	RemovePlayer(session->GetGUID());
 
 	if (m_ServerTurnManager && session->GetCurrState() != NSS_JOIN_SYNCING)
 		m_ServerTurnManager->UninitialiseClient(session->GetHostID()); // TODO: only for non-observers
-
-	// TODO: ought to switch the player controlled by that client
-	// back to AI control, or something?
 }
 
 void CNetServerWorker::AddPlayer(const CStr& guid, const CStrW& name)
 {
 	// Find all player IDs in active use; we mustn't give them to a second player (excluding the unassigned ID: -1)
@@ -706,10 +716,50 @@
 		it->second.m_Status = 0;
 
 	SendPlayerAssignments();
 }
 
+void CNetServerWorker::KickPlayer(const CStrW& playerName, const bool ban)
+{
+	// Find the user with that name
+	std::vector<CNetServerSession*>::iterator it = std::find_if(m_Sessions.begin(), m_Sessions.end(),
+		[&](CNetServerSession* session) { return session->GetUserName() == playerName; });
+
+	// and return if no one or the host has that name
+	if (it == m_Sessions.end() || (*it)->GetGUID() == m_HostGUID)
+		return;
+
+	if (ban)
+	{
+		// Remember name
+		if (std::find(m_BannedPlayers.begin(), m_BannedPlayers.end(), playerName) == m_BannedPlayers.end())
+			m_BannedPlayers.push_back(playerName);
+
+		// Remember IP address
+		CStr ipAddress = GetPlayerIPAddress(playerName);
+		if (std::find(m_BannedIPs.begin(), m_BannedIPs.end(), ipAddress) == m_BannedIPs.end())
+			m_BannedIPs.push_back(ipAddress);
+	}
+
+	// Disconnect that user
+	(*it)->Disconnect(NDR_UNKNOWN);
+
+	// Send message notifying other clients
+	CKickedMessage kickedMessage;
+	kickedMessage.m_Name = playerName;
+	kickedMessage.m_Ban = ban;
+	Broadcast(&kickedMessage);
+}
+
+CStr CNetServerWorker::GetPlayerIPAddress(const CStrW& playerName)
+{
+	for (CNetServerSession* session : m_Sessions)
+		if (session->GetUserName() == playerName)
+			return session->GetIPAddress();
+	return "(error)";
+}
+
 void CNetServerWorker::AssignPlayer(int playerID, const CStr& guid)
 {
 	// Remove anyone who's already assigned to this player
 	for (PlayerAssignmentMap::iterator it = m_PlayerAssignments.begin(); it != m_PlayerAssignments.end(); ++it)
 	{
@@ -763,17 +813,19 @@
 	ENSURE(event->GetType() == (uint)NMT_CLIENT_HANDSHAKE);
 
 	CNetServerSession* session = (CNetServerSession*)context;
 	CNetServerWorker& server = session->GetServer();
 
+	// Check protocol version
 	CCliHandshakeMessage* message = (CCliHandshakeMessage*)event->GetParamRef();
 	if (message->m_ProtocolVersion != PS_PROTOCOL_VERSION)
 	{
 		session->Disconnect(NDR_INCORRECT_PROTOCOL_VERSION);
 		return false;
 	}
 
+	// Send handshake response
 	CSrvHandshakeResponseMessage handshakeResponse;
 	handshakeResponse.m_UseProtocolVersion = PS_PROTOCOL_VERSION;
 	handshakeResponse.m_Message = server.m_WelcomeMessage;
 	handshakeResponse.m_Flags = 0;
 	session->SendMessage(&handshakeResponse);
@@ -790,10 +842,17 @@
 
 	CAuthenticateMessage* message = (CAuthenticateMessage*)event->GetParamRef();
 
 	CStrW username = server.DeduplicatePlayerName(SanitisePlayerName(message->m_Name));
 
+	// Disconnect banned usernames
+	if (std::find(server.m_BannedPlayers.begin(), server.m_BannedPlayers.end(), username) != server.m_BannedPlayers.end())
+	{
+		session->Disconnect(NDR_UNKNOWN);
+		return true;
+	}
+
 	bool isRejoining = false;
 
 	if (server.m_State != SERVER_STATE_PREGAME)
 	{
 // 		isRejoining = true; // uncomment this to test rejoining even if the player wasn't connected previously
@@ -1107,10 +1166,16 @@
 bool CNetServer::SetupConnection()
 {
 	return m_Worker->SetupConnection();
 }
 
+void CNetServer::KickPlayer(const CStrW& playerName, const bool ban)
+{
+	CScopeLock lock(m_Worker->m_WorkerMutex);
+	m_Worker->KickPlayer(playerName, ban);
+}
+
 void CNetServer::AssignPlayer(int playerID, const CStr& guid)
 {
 	CScopeLock lock(m_Worker->m_WorkerMutex);
 	m_Worker->m_AssignPlayerQueue.push_back(std::make_pair(playerID, guid));
 }
Index: source/network/NetServer.h
===================================================================
--- source/network/NetServer.h	(revision 16411)
+++ source/network/NetServer.h	(working copy)
@@ -120,11 +120,11 @@
 	 * The given GUID will be (re)assigned to the given player ID.
 	 * Any player currently using that ID will be unassigned.
 	 * The changes will be asynchronously propagated to all clients.
 	 */
 	void AssignPlayer(int playerID, const CStr& guid);
-	
+
 	/**
 	 * Call from the GUI to update the player readiness.
 	 * The changes will be asynchronously propagated to all clients.
 	 */
 	void SetPlayerReady(const CStr& guid, int ready);
@@ -132,11 +132,16 @@
 	/**
 	 * Call from the GUI to set the all player readiness to 0.
 	 * The changes will be asynchronously propagated to all clients.
 	 */
 	void ClearAllPlayerReady();
-	
+
+	/**
+	 * Disconnects a player from the gamesetup / session.
+	 */
+	void KickPlayer(const CStrW& playerName, const bool ban);
+
 	/**
 	 * Call from the GUI to asynchronously notify all clients that they should start loading the game.
 	 */
 	void StartGame();
 
@@ -181,15 +186,25 @@
 	 * Send a message to the given network peer.
 	 */
 	bool SendMessage(ENetPeer* peer, const CNetMessage* message);
 
 	/**
+	 * Disconnected a player from the match / gamesetup and optionally prevents him/her from rejoining.
+	 */
+	void KickPlayer(const CStrW& playerName, const bool ban);
+
+	/**
 	 * Send a message to all clients who have completed the full connection process
 	 * (i.e. are in the pre-game or in-game states).
 	 */
 	bool Broadcast(const CNetMessage* message);
 
+	/**
+	 * Returns the IP address of the given connected player.
+	 */
+	CStr GetPlayerIPAddress(const CStrW& playerName);
+
 private:
 	friend class CNetServer;
 	friend class CNetFileReceiveTask_ServerRejoin;
 
 	CNetServerWorker(int autostartPlayers);
@@ -243,11 +258,12 @@
 	 */
 	void SetTurnLength(u32 msecs);
 
 	void AddPlayer(const CStr& guid, const CStrW& name);
 	void RemovePlayer(const CStr& guid);
-	void SetPlayerReady(const CStr& guid, const int ready); 
+	void SetPlayerReady(const CStr& guid, const int ready);
+	CStr GetHostGUID();
 	void SendPlayerAssignments();
 	void ClearAllPlayerReady();
 
 	void SetupSession(CNetServerSession* session);
 	bool HandleConnect(CNetServerSession* session);
@@ -268,11 +284,10 @@
 
 	void ConstructPlayerAssignmentMessage(CPlayerAssignmentMessage& message);
 
 	void HandleMessageReceive(const CNetMessage* message, CNetServerSession* session);
 
-
 	/**
 	 * Internal script context for (de)serializing script messages,
 	 * and for storing game attributes.
 	 * (TODO: we shouldn't bother deserializing (except for debug printing of messages),
 	 * we should just forward messages blindly and efficiently.)
@@ -296,14 +311,19 @@
 	NetServerState m_State;
 
 	CStrW m_ServerName;
 	CStrW m_WelcomeMessage;
 
+	std::vector<CStr> m_BannedIPs;
+	std::vector<CStrW> m_BannedPlayers;
+
 	u32 m_NextHostID;
 
 	CNetServerTurnManager* m_ServerTurnManager;
 
+	CStr m_HostGUID;
+
 	/**
 	 * A copy of all simulation commands received so far, indexed by
 	 * turn number, to simplify support for rejoining etc.
 	 * TODO: verify this doesn't use too much RAM.
 	 */
Index: source/network/NetSession.cpp
===================================================================
--- source/network/NetSession.cpp	(revision 16411)
+++ source/network/NetSession.cpp	(working copy)
@@ -1,6 +1,6 @@
-/* Copyright (C) 2011 Wildfire Games.
+/* Copyright (C) 2015 Wildfire Games.
  * This file is part of 0 A.D.
  *
  * 0 A.D. is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 2 of the License, or
@@ -173,10 +173,17 @@
 CNetServerSession::CNetServerSession(CNetServerWorker& server, ENetPeer* peer) :
 	m_Server(server), m_FileTransferer(this), m_Peer(peer)
 {
 }
 
+CStr CNetServerSession::GetIPAddress()
+{
+	char ipAddress[256] = "(error)";
+	enet_address_get_host_ip(&(m_Peer->address), ipAddress, ARRAY_SIZE(ipAddress));
+	return CStr(ipAddress);
+}
+
 void CNetServerSession::Disconnect(u32 reason)
 {
 	Update((uint)NMT_CONNECTION_LOST, NULL);
 
 	enet_peer_disconnect(m_Peer, reason);
Index: source/network/NetSession.h
===================================================================
--- source/network/NetSession.h	(revision 16411)
+++ source/network/NetSession.h	(working copy)
@@ -1,6 +1,6 @@
-/* Copyright (C) 2011 Wildfire Games.
+/* Copyright (C) 2015 Wildfire Games.
  * This file is part of 0 A.D.
  *
  * 0 A.D. is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 2 of the License, or
@@ -121,10 +121,15 @@
 
 	u32 GetHostID() const { return m_HostID; }
 	void SetHostID(u32 id) { m_HostID = id; }
 
 	/**
+	 * Returns the IP address of the client.
+	 */
+	CStr GetIPAddress();
+
+	/**
 	 * Sends a disconnection notification to the client,
 	 * and sends a NMT_CONNECTION_LOST message to the session FSM.
 	 * The server will receive a disconnection notification after a while.
 	 * The server will not receive any further messages sent via this session.
 	 */
Index: source/network/NetTurnManager.cpp
===================================================================
--- source/network/NetTurnManager.cpp	(revision 16411)
+++ source/network/NetTurnManager.cpp	(working copy)
@@ -1,6 +1,6 @@
-/* Copyright (C) 2012 Wildfire Games.
+/* Copyright (C) 2015 Wildfire Games.
  * This file is part of 0 A.D.
  *
  * 0 A.D. is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 2 of the License, or
@@ -223,30 +223,53 @@
 	NETTURN_LOG((L"OnSyncError(%d, %hs)\n", turn, Hexify(expectedHash).c_str()));
 
 	// Only complain the first time
 	if (m_HasSyncError)
 		return;
-	m_HasSyncError = true;
 
 	bool quick = !TurnNeedsFullHash(turn);
 	std::string hash;
-	bool ok = m_Simulation2.ComputeStateHash(hash, quick);
-	ENSURE(ok);
+	ENSURE(m_Simulation2.ComputeStateHash(hash, quick));
 
 	OsPath path = psLogDir()/"oos_dump.txt";
 	std::ofstream file (OsString(path).c_str(), std::ofstream::out | std::ofstream::trunc);
 	m_Simulation2.DumpDebugState(file);
 	file.close();
 
+	hash = Hexify(hash);
+	const std::string& expectedHashHex = Hexify(expectedHash);
+
+	DisplayOOSError(turn, hash, expectedHashHex, false, &path);
+}
+
+void CNetTurnManager::DisplayOOSError(u32 turn, std::string& hash, const std::string& expectedHash, const bool isReplay, OsPath* path = NULL)
+{
+	m_HasSyncError = true;
+
 	std::stringstream msg;
-	msg << "Out of sync on turn " << turn << ": expected hash " << Hexify(expectedHash) << "\n\n";
-	msg << "Current state: turn " << m_CurrentTurn << ", hash " << Hexify(hash) << "\n\n";
-	msg << "Dumping current state to " << utf8_from_wstring(path.string());
+	msg << "Out of sync on turn " << turn << ": expected hash " << expectedHash << "\n";
+
+	if (expectedHash != hash || m_CurrentTurn != turn)
+		msg << "\nCurrent state: turn " << m_CurrentTurn << ", hash " << hash << "\n\n";
+
+	if (isReplay)
+		msg << "\nThe current game state is different from the original game state.\n\n";
+	else
+	{
+		if (expectedHash == hash)
+			msg << "Your game state is identical to the hosts game state.\n\n";
+		else
+			msg << "Your game state is different from the hosts game state.\n\n";
+	}
+
+	if (path)
+		msg << "Dumping current state to " << utf8_from_wstring(OsPath(*path).string());
+
+	LOGERROR("%s", msg.str());
+
 	if (g_GUI)
 		g_GUI->DisplayMessageBox(600, 350, L"Sync error", wstring_from_utf8(msg.str()));
-	else
-		LOGERROR("%s", msg.str());
 }
 
 void CNetTurnManager::Interpolate(float simFrameLength, float realFrameLength)
 {
 	// TODO: using m_TurnLength might be a bit dodgy when length changes - maybe
@@ -320,12 +343,11 @@
 void CNetTurnManager::QuickSave()
 {
 	TIMER(L"QuickSave");
 	
 	std::stringstream stream;
-	bool ok = m_Simulation2.SerializeState(stream);
-	if (!ok)
+	if (!m_Simulation2.SerializeState(stream))
 	{
 		LOGERROR("Failed to quicksave game");
 		return;
 	}
 
@@ -348,12 +370,11 @@
 		LOGERROR("Cannot quickload game - no game was quicksaved");
 		return;
 	}
 
 	std::stringstream stream(m_QuickSaveState);
-	bool ok = m_Simulation2.DeserializeState(stream);
-	if (!ok)
+	if (!m_Simulation2.DeserializeState(stream))
 	{
 		LOGERROR("Failed to quickload game");
 		return;
 	}
 
@@ -400,12 +421,11 @@
 {
 	bool quick = !TurnNeedsFullHash(turn);
 	std::string hash;
 	{
 		PROFILE3("state hash check");
-		bool ok = m_Simulation2.ComputeStateHash(hash, quick);
-		ENSURE(ok);
+		ENSURE(m_Simulation2.ComputeStateHash(hash, quick));
 	}
 
 	NETTURN_LOG((L"NotifyFinishedUpdate(%d, %hs)\n", turn, Hexify(hash).c_str()));
 
 	m_Replay.Hash(hash, quick);
@@ -450,24 +470,88 @@
 {
 #if 0 // this hurts performance and is only useful for verifying log replays
 	std::string hash;
 	{
 		PROFILE3("state hash check");
-		bool ok = m_Simulation2.ComputeStateHash(hash);
-		ENSURE(ok);
+		ENSURE(m_Simulation2.ComputeStateHash(hash));
 	}
 	m_Replay.Hash(hash);
 #endif
 }
 
 void CNetLocalTurnManager::OnSimulationMessage(CSimulationMessage* UNUSED(msg))
 {
 	debug_warn(L"This should never be called");
 }
 
+CNetReplayTurnManager::CNetReplayTurnManager(CSimulation2& simulation, IReplayLogger& replay) :
+	CNetLocalTurnManager(simulation, replay)
+{
+}
+
+void CNetReplayTurnManager::StoreReplayCommand(u32 turn, int player, const std::string& command)
+{
+	// Using the pair we make sure that commands per turn will be processed in the correct order
+	m_ReplayCommands[turn].push_back(std::make_pair(player, command));
+}
+
+void CNetReplayTurnManager::StoreReplayHash(u32 turn, const std::string& hash, bool quick)
+{
+	m_ReplayHash[turn] = std::make_pair(hash, quick);
+}
+
+void CNetReplayTurnManager::StoreReplayTurnLength(u32 turn, u32 turnLength)
+{
+	m_ReplayTurnLengths[turn] = turnLength;
+
+	// Initialize turn length
+	if (turn == 0)
+		m_TurnLength = m_ReplayTurnLengths[0];
+}
+
+void CNetReplayTurnManager::StoreFinalReplayTurn(u32 turn)
+{
+	m_FinalReplayTurn = turn;
+}
+
+void CNetReplayTurnManager::NotifyFinishedUpdate(u32 turn)
+{
+	if (turn > m_FinalReplayTurn)
+		return;
 
+	debug_printf("Executing turn %d of %d\n", turn, m_FinalReplayTurn);
+	DoTurn(turn);
 
+	// Compare hash if it exists in the replay and if we didn't have an oos already
+	if (m_HasSyncError || m_ReplayHash.find(turn) == m_ReplayHash.end())
+		return;
+
+	std::string expectedHash = m_ReplayHash[turn].first;
+	bool quickHash = m_ReplayHash[turn].second;
+
+	// Compute hash
+	std::string hash;
+	ENSURE(m_Simulation2.ComputeStateHash(hash, quickHash));
+	hash = Hexify(hash);
+
+	if (hash != expectedHash)
+		DisplayOOSError(turn-1, hash, expectedHash, true);
+}
+
+void CNetReplayTurnManager::DoTurn(u32 turn)
+{
+	// Save turn length
+	m_TurnLength = m_ReplayTurnLengths[turn];
+
+	// Simulate commands for that turn
+	for(std::vector<std::pair<player_id_t, std::string> >::iterator it = m_ReplayCommands[turn].begin(); it != m_ReplayCommands[turn].end(); ++it)
+	{
+		JS::RootedValue command(m_Simulation2.GetScriptInterface().GetContext());
+		m_Simulation2.GetScriptInterface().ParseJSON(it->second, &command);
+		AddCommand(m_ClientId, it->first, command, m_CurrentTurn + 1);
+	}
+}
 
 CNetServerTurnManager::CNetServerTurnManager(CNetServerWorker& server) :
 	m_NetServer(server), m_ReadyTurn(1), m_TurnLength(DEFAULT_TURN_LENGTH_MP)
 {
 	// The first turn we will actually execute is number 2,
Index: source/network/NetTurnManager.h
===================================================================
--- source/network/NetTurnManager.h	(revision 16411)
+++ source/network/NetTurnManager.h	(working copy)
@@ -1,6 +1,6 @@
-/* Copyright (C) 2012 Wildfire Games.
+/* Copyright (C) 2015 Wildfire Games.
  * This file is part of 0 A.D.
  *
  * 0 A.D. is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 2 of the License, or
@@ -17,13 +17,15 @@
 
 #ifndef INCLUDED_NETTURNMANAGER
 #define INCLUDED_NETTURNMANAGER
 
 #include "simulation2/helpers/SimulationCommand.h"
+#include "lib/os_path.h"
 
 #include <list>
 #include <map>
+#include <vector>
 
 class CNetServerWorker;
 class CNetClient;
 class CSimulationMessage;
 class CSimulation2;
@@ -106,10 +108,15 @@
 	 * Called when there has been an out-of-sync error.
 	 */
 	virtual void OnSyncError(u32 turn, const std::string& expectedHash);
 
 	/**
+	 * Shows a message box when an out of sync error has been detected in the session or visual replay.
+	 */
+	virtual void DisplayOOSError(u32 turn, std::string& hash, const std::string& expectedHash, const bool isReplay, OsPath* path);
+
+	/**
 	 * Called by simulation code, to add a new command to be distributed to all clients and executed soon.
 	 */
 	virtual void PostCommand(JS::HandleValue data) = 0;
 
 	/**
@@ -187,10 +194,11 @@
 	std::list<std::string> m_TimeWarpStates;
 	std::string m_QuickSaveState; // TODO: should implement a proper disk-based quicksave system
 	std::string m_QuickSaveMetadata;
 };
 
+
 /**
  * Implementation of CNetTurnManager for network clients.
  */
 class CNetClientTurnManager : public CNetTurnManager
 {
@@ -231,10 +239,45 @@
 
 	virtual void NotifyFinishedUpdate(u32 turn);
 };
 
 
+
+/**
+ * Implementation of CNetTurnManager for replay games.
+ */
+class CNetReplayTurnManager : public CNetLocalTurnManager
+{
+public:
+	CNetReplayTurnManager(CSimulation2& simulation, IReplayLogger& replay);
+
+	void StoreReplayCommand(u32 turn, int player, const std::string& command);
+
+	void StoreReplayTurnLength(u32 turn, u32 turnLength);
+
+	void StoreReplayHash(u32 turn, const std::string& hash, bool quick);
+
+	void StoreFinalReplayTurn(u32 turn);
+
+
+protected:
+	virtual void NotifyFinishedUpdate(u32 turn);
+
+	void DoTurn(u32 turn);
+
+	// Contains the commands of every player on each turn
+	std::map<u32, std::vector<std::pair<player_id_t, std::string> > > m_ReplayCommands;
+
+	// Contains the length of every turn
+	std::map<u32, u32> m_ReplayTurnLengths;
+
+	// Contains all replay hash values and weather or not the quick hash method was used
+	std::map<u32, std::pair<std::string, bool> > m_ReplayHash;
+
+	// The number of the last turn in the replay
+	u32 m_FinalReplayTurn;
+};
 /**
  * The server-side counterpart to CNetClientTurnManager.
  * Records the turn state of each client, and sends turn advancement messages
  * when all clients are ready.
  *
Index: source/ps/Game.cpp
===================================================================
--- source/ps/Game.cpp	(revision 16411)
+++ source/ps/Game.cpp	(working copy)
@@ -61,22 +61,27 @@
 
 /**
  * Constructor
  *
  **/
-CGame::CGame(bool disableGraphics):
+CGame::CGame(bool disableGraphics, bool replayLog):
 	m_World(new CWorld(this)),
 	m_Simulation2(new CSimulation2(&m_World->GetUnitManager(), g_ScriptRuntime, m_World->GetTerrain())),
 	m_GameView(disableGraphics ? NULL : new CGameView(this)),
 	m_GameStarted(false),
 	m_Paused(false),
 	m_SimRate(1.0f),
 	m_PlayerID(-1),
-	m_IsSavedGame(false)
+	m_IsSavedGame(false),
+	m_IsReplay(false),
+	m_ReplayStream(NULL)
 {
-	m_ReplayLogger = new CReplayLogger(m_Simulation2->GetScriptInterface());
 	// TODO: should use CDummyReplayLogger unless activated by cmd-line arg, perhaps?
+	if (replayLog)
+		m_ReplayLogger = new CReplayLogger(m_Simulation2->GetScriptInterface());
+	else
+		m_ReplayLogger = new CDummyReplayLogger();
 
 	// Need to set the CObjectManager references after various objects have
 	// been initialised, so do it here rather than via the initialisers above.
 	if (m_GameView)
 		m_World->GetUnitManager().SetObjectManager(m_GameView->GetObjectManager());
@@ -99,10 +104,11 @@
 	delete m_TurnManager;
 	delete m_GameView;
 	delete m_Simulation2;
 	delete m_World;
 	delete m_ReplayLogger;
+	delete m_ReplayStream;
 }
 
 void CGame::SetTurnManager(CNetTurnManager* turnManager)
 {
 	if (m_TurnManager)
@@ -112,10 +118,80 @@
 
 	if (m_TurnManager)
 		m_TurnManager->SetPlayerID(m_PlayerID);
 }
 
+int CGame::LoadReplayData()
+{
+	ENSURE(m_IsReplay);
+	ENSURE(!m_ReplayPath.empty());
+
+	CNetReplayTurnManager* replayTurnMgr = static_cast<CNetReplayTurnManager*>(GetTurnManager());
+
+	u32 currentTurn = 0;
+	std::string type;
+	while ((*m_ReplayStream >> type).good())
+	{
+		if (type == "turn")
+		{
+			u32 turn = 0;
+			u32 turnLength = 0;
+			*m_ReplayStream >> turn >> turnLength;
+			ENSURE(turn == currentTurn);
+			replayTurnMgr->StoreReplayTurnLength(currentTurn, turnLength);
+		}
+		else if (type == "cmd")
+		{
+			player_id_t player;
+			*m_ReplayStream >> player;
+
+			std::string line;
+			std::getline(*m_ReplayStream, line);
+			replayTurnMgr->StoreReplayCommand(currentTurn, player, line);
+		}
+		else if (type == "hash" || type == "hash-quick")
+		{
+			bool quick = (type == "hash-quick");
+			std::string replayHash;
+			*m_ReplayStream >> replayHash;
+			replayTurnMgr->StoreReplayHash(currentTurn, replayHash, quick);
+		}
+		else if (type == "end")
+		{
+			currentTurn++;
+		}
+		else
+		{
+			CancelLoad(L"Failed to load replay data (unrecognized content)");
+		}
+	}
+	m_FinalReplayTurn = currentTurn;
+	replayTurnMgr->StoreFinalReplayTurn(currentTurn);
+	return 0;
+}
+
+bool CGame::StartReplay(const std::string& replayPath)
+{
+	m_IsReplay = true;
+	ScriptInterface& scriptInterface = m_Simulation2->GetScriptInterface();
+
+	SetTurnManager(new CNetReplayTurnManager(*m_Simulation2, GetReplayLogger()));
+
+	m_ReplayPath = replayPath;
+	m_ReplayStream = new std::ifstream(m_ReplayPath.c_str());
+
+	std::string type;
+	ENSURE((*m_ReplayStream >> type).good() && type == "start");
+
+	std::string line;
+	std::getline(*m_ReplayStream, line);
+	JS::RootedValue attribs(scriptInterface.GetContext());
+	scriptInterface.ParseJSON(line, &attribs);
+	StartGame(&attribs, "");
+
+	return true;
+}
 
 /**
  * Initializes the game with the set of attributes provided.
  * Makes calls to initialize the game view, world, and simulation objects.
  * Calls are made to facilitate progress reporting of the initialization.
@@ -174,10 +250,13 @@
 		RegMemFun(g_Renderer.GetSingletonPtr()->GetWaterManager(), &WaterManager::LoadWaterTextures, L"LoadWaterTextures", 80);
 
 	if (m_IsSavedGame)
 		RegMemFun(this, &CGame::LoadInitialState, L"Loading game", 1000);
 
+	if (m_IsReplay)
+		RegMemFun(this, &CGame::LoadReplayData, L"Loading replay data", 1000);
+
 	LDR_EndRegistering();
 }
 
 int CGame::LoadInitialState()
 {
@@ -261,20 +340,22 @@
 int CGame::GetPlayerID()
 {
 	return m_PlayerID;
 }
 
-void CGame::SetPlayerID(int playerID)
+void CGame::SetPlayerID(player_id_t playerID)
 {
 	m_PlayerID = playerID;
 	if (m_TurnManager)
 		m_TurnManager->SetPlayerID(m_PlayerID);
 }
 
 void CGame::StartGame(JS::MutableHandleValue attribs, const std::string& savedState)
 {
-	m_ReplayLogger->StartGame(attribs);
+	if (m_ReplayLogger != false)
+		m_ReplayLogger->StartGame(attribs);
+
 	RegisterInit(attribs, savedState);
 }
 
 // TODO: doInterpolate is optional because Atlas interpolates explicitly,
 // so that it has more control over the update rate. The game might want to
@@ -308,10 +389,12 @@
 		{
 			{
 				PROFILE3("gui sim update");
 				g_GUI->SendEventToAll("SimulationUpdate");
 			}
+			if (m_IsReplay && m_TurnManager->GetCurrentTurn() == m_FinalReplayTurn - 1)
+				g_GUI->SendEventToAll("ReplayFinished");
 
 			GetView()->GetLOSTexture().MakeDirty();
 		}
 		
 		if (CRenderer::IsInitialised())
@@ -360,11 +443,11 @@
 			m_PlayerColours[i] = cmpPlayer->GetColour();
 	}
 }
 
 
-CColor CGame::GetPlayerColour(int player) const
+CColor CGame::GetPlayerColour(player_id_t player) const
 {
 	if (player < 0 || player >= (int)m_PlayerColours.size())
 		return BrokenColor;
 
 	return m_PlayerColours[player];
Index: source/ps/Game.h
===================================================================
--- source/ps/Game.h	(revision 16411)
+++ source/ps/Game.h	(working copy)
@@ -1,6 +1,6 @@
-/* Copyright (C) 2013 Wildfire Games.
+/* Copyright (C) 2015 Wildfire Games.
  * This file is part of 0 A.D.
  *
  * 0 A.D. is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 2 of the License, or
@@ -20,10 +20,11 @@
 
 #include "ps/Errors.h"
 #include <vector>
 
 #include "scriptinterface/ScriptVal.h"
+#include "simulation2/helpers/Player.h"
 
 class CWorld;
 class CSimulation2;
 class CGameView;
 class CNetTurnManager;
@@ -58,26 +59,28 @@
 	/**
 	 * Timescale multiplier for simulation rate.
 	 **/
 	float m_SimRate;
 
-	int m_PlayerID;
+	player_id_t m_PlayerID;
 
 	CNetTurnManager* m_TurnManager;
 
 public:
-	CGame(bool disableGraphics = false);
+	CGame(bool disableGraphics = false, bool replayLog = true);
 	~CGame();
 
 	/**
 	 * the game is paused and no updates will be performed if true.
 	 **/
 	bool m_Paused;
 
 	void StartGame(JS::MutableHandleValue attribs, const std::string& savedState);
 	PSRETURN ReallyStartGame();
 
+	bool StartReplay(const std::string& replayPath);
+
 	/**
 	 * Periodic heartbeat that controls the process. performs all per-frame updates.
 	 * Simulation update is called and game status update is called.
 	 *
 	 * @param deltaRealTime Elapsed real time since last beat/frame, in seconds.
@@ -88,21 +91,21 @@
 	bool Update(const double deltaRealTime, bool doInterpolate = true);
 
 	void Interpolate(float simFrameLength, float realFrameLength);
 
 	int GetPlayerID();
-	void SetPlayerID(int playerID);
+	void SetPlayerID(player_id_t playerID);
 
 	/**
 	 * Retrieving player colours from scripts is slow, so this updates an
 	 * internal cache of all players' colours.
 	 * Call this just before rendering, so it will always have the latest
 	 * colours.
 	 */
 	void CachePlayerColours();
 
-	CColor GetPlayerColour(int player) const;
+	CColor GetPlayerColour(player_id_t player) const;
 
 	/**
 	 * Get m_GameStarted.
 	 *
 	 * @return bool the value of m_GameStarted.
@@ -169,10 +172,16 @@
 	std::vector<CColor> m_PlayerColours;
 
 	int LoadInitialState();
 	std::string m_InitialSavedState; // valid between RegisterInit and LoadInitialState
 	bool m_IsSavedGame; // true if loading a saved game; false for a new game
+
+	int LoadReplayData();
+	std::string m_ReplayPath;
+	bool m_IsReplay;
+	std::istream* m_ReplayStream;
+	u32 m_FinalReplayTurn;
 };
 
 extern CGame *g_Game;
 
 #endif
Index: source/ps/GameSetup/GameSetup.cpp
===================================================================
--- source/ps/GameSetup/GameSetup.cpp	(revision 16411)
+++ source/ps/GameSetup/GameSetup.cpp	(working copy)
@@ -880,10 +880,13 @@
 	srand(time(NULL));	// NOTE: this rand should *not* be used for simulation!
 }
 
 bool Autostart(const CmdLineArgs& args);
 
+// Returns true if and only if the user has intended to replay a file
+bool VisualReplay(const std::string replayFile);
+
 bool Init(const CmdLineArgs& args, int flags)
 {
 	h_mgr_init();
 
 	// Do this as soon as possible, because it chdirs
@@ -1072,11 +1075,11 @@
 
 	ogl_WarnIfError();
 
 	try
 	{
-		if (!Autostart(args))
+		if (!VisualReplay(args.Get("replay-visual")) && !Autostart(args))
 		{
 			const bool setup_gui = ((flags & INIT_NO_GUI) == 0);
 			// We only want to display the splash screen at startup
 			shared_ptr<ScriptInterface> scriptInterface = g_GUI->GetScriptInterface();
 			JSContext* cx = scriptInterface->GetContext();
@@ -1472,10 +1475,31 @@
 	}
 
 	return true;
 }
 
+bool VisualReplay(const std::string replayFile)
+{
+	if (!FileExists(OsPath(replayFile)))
+		return false;
+
+	g_Game = new CGame(false, false);
+	g_Game->SetPlayerID(-1);
+	g_Game->StartReplay(replayFile);
+
+	// TODO: Non progressive load can fail - need a decent way to handle this
+	LDR_NonprogressiveLoad();
+
+	PSRETURN ret = g_Game->ReallyStartGame();
+	ENSURE(ret == PSRETURN_OK);
+
+	ScriptInterface& scriptInterface = g_Game->GetSimulation2()->GetScriptInterface();
+
+	InitPs(true, L"page_session.xml", &scriptInterface, JS::UndefinedHandleValue);
+	return true;
+}
+
 void CancelLoad(const CStrW& message)
 {
 	shared_ptr<ScriptInterface> pScriptInterface = g_GUI->GetActiveGUI()->GetScriptInterface();
 	JSContext* cx = pScriptInterface->GetContext();
 	JSAutoRequest rq(cx);
Index: source/ps/Replay.cpp
===================================================================
--- source/ps/Replay.cpp	(revision 16411)
+++ source/ps/Replay.cpp	(working copy)
@@ -1,6 +1,6 @@
-/* Copyright (C) 2014 Wildfire Games.
+/* Copyright (C) 2015 Wildfire Games.
  * This file is part of 0 A.D.
  *
  * 0 A.D. is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 2 of the License, or
@@ -31,19 +31,15 @@
 #include "scriptinterface/ScriptInterface.h"
 #include "scriptinterface/ScriptStats.h"
 #include "simulation2/Simulation2.h"
 #include "simulation2/helpers/SimulationCommand.h"
 
+#include <ctime>
 #include <sstream>
 #include <fstream>
 #include <iomanip>
 
-#if MSC_VERSION
-#include <process.h>
-#define getpid _getpid // use the non-deprecated function name
-#endif
-
 static std::string Hexify(const std::string& s)
 {
 	std::stringstream str;
 	str << std::hex;
 	for (size_t i = 0; i < s.size(); ++i)
@@ -52,22 +48,29 @@
 }
 
 CReplayLogger::CReplayLogger(ScriptInterface& scriptInterface) :
 	m_ScriptInterface(scriptInterface)
 {
-	// Construct the directory name based on the PID, to be relatively unique.
-	// Append "-1", "-2" etc if we run multiple matches in a single session,
-	// to avoid accidentally overwriting earlier logs.
-
-	std::wstringstream name;
-	name << getpid();
-
-	static int run = -1;
-	if (++run)
-		name << "-" << run;
+	// Get current date
+	time_t t = time(NULL);
+	struct tm* now = localtime(&t);
+	char date[16];
+	sprintf_s(date, ARRAY_SIZE(date), "%04d-%02d-%02d_a18_", 1900+now->tm_year, 1+now->tm_mon, now->tm_mday);
+
+	// Construct a unique directory name based on date and sequential number per date
+	int i = 1;
+	OsPath path;
+	std::stringstream pathname;
+	do
+	{
+		pathname.str("");
+		pathname.clear();
+		pathname << date << i++;
+		path = psLogDir() / L"sim_log" / pathname.str() / L"commands.txt";
+	} while(DirectoryExists(path.Parent()));
 
-	OsPath path = psLogDir() / L"sim_log" / name.str() / L"commands.txt";
+	// Create directory and commands.txt
 	CreateDirectories(path.Parent(), 0700);
 	m_Stream = new std::ofstream(OsString(path).c_str(), std::ofstream::out | std::ofstream::trunc);
 }
 
 CReplayLogger::~CReplayLogger()
@@ -120,11 +123,11 @@
 
 	m_Stream = new std::ifstream(path.c_str());
 	ENSURE(m_Stream->good());
 }
 
-void CReplayPlayer::Replay(bool serializationtest)
+void CReplayPlayer::Replay(bool serializationtest, bool ooslog)
 {
 	ENSURE(m_Stream);
 
 	new CProfileViewer;
 	new CProfileManager;
@@ -137,10 +140,12 @@
 
 	CGame game(true);
 	g_Game = &game;
 	if (serializationtest)
 		game.GetSimulation2()->EnableSerializationTest();
+	if (ooslog)
+		game.GetSimulation2()->EnableOOSLog();
 		
 	JSContext* cx = game.GetSimulation2()->GetScriptInterface().GetContext();
 	JSAutoRequest rq(cx);
 
 	// Need some stuff for terrain movement costs:
Index: source/ps/Replay.h
===================================================================
--- source/ps/Replay.h	(revision 16411)
+++ source/ps/Replay.h	(working copy)
@@ -1,6 +1,6 @@
-/* Copyright (C) 2014 Wildfire Games.
+/* Copyright (C) 2015 Wildfire Games.
  * This file is part of 0 A.D.
  *
  * 0 A.D. is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 2 of the License, or
@@ -54,11 +54,11 @@
  */
 class CDummyReplayLogger : public IReplayLogger
 {
 public:
 	virtual void StartGame(JS::MutableHandleValue UNUSED(attribs)) { }
-	virtual void Turn(u32 UNUSED(n), u32 UNUSED(turnLength), const std::vector<SimulationCommand>& UNUSED(commands)) { }
+	virtual void Turn(u32 UNUSED(n), u32 UNUSED(turnLength), std::vector<SimulationCommand>& UNUSED(commands)) { }
 	virtual void Hash(const std::string& UNUSED(hash), bool UNUSED(quick)) { }
 };
 
 /**
  * Implementation of IReplayLogger that saves data to a file in the logs directory.
@@ -87,11 +87,11 @@
 public:
 	CReplayPlayer();
 	~CReplayPlayer();
 
 	void Load(const std::string& path);
-	void Replay(bool serializationtest);
+	void Replay(bool serializationtest, bool ooslog);
 
 private:
 	std::istream* m_Stream;
 };
 
Index: source/simulation2/components/CCmpRangeManager.cpp
===================================================================
--- source/simulation2/components/CCmpRangeManager.cpp	(revision 16411)
+++ source/simulation2/components/CCmpRangeManager.cpp	(working copy)
@@ -903,10 +903,29 @@
 		}
 
 		return entities;
 	}
 
+	virtual std::vector<entity_id_t> GetAllPlayerEntities()
+	{
+		// Compute ownership mask for all players
+		u32 ownerMask = 0;
+		for (player_id_t player = 1; player < MAX_LOS_PLAYER_ID + 1; ++player)
+			ownerMask |= CalcOwnerMask(player);
+
+		// Get a list of all entities of all players
+		std::vector<entity_id_t> entities;
+		for (EntityMap<EntityData>::const_iterator it = m_EntityData.begin(); it != m_EntityData.end(); ++it)
+		{
+			// Check owner and add to list if it matches
+			if (CalcOwnerMask(it->second.owner) & ownerMask)
+				entities.push_back(it->first);
+		}
+
+		return entities;
+	}
+
 	virtual void SetDebugOverlay(bool enabled)
 	{
 		m_DebugOverlayEnabled = enabled;
 		m_DebugOverlayDirty = true;
 		if (!enabled)
Index: source/simulation2/components/ICmpRangeManager.cpp
===================================================================
--- source/simulation2/components/ICmpRangeManager.cpp	(revision 16411)
+++ source/simulation2/components/ICmpRangeManager.cpp	(working copy)
@@ -43,10 +43,11 @@
 DEFINE_INTERFACE_METHOD_1("DisableActiveQuery", void, ICmpRangeManager, DisableActiveQuery, ICmpRangeManager::tag_t)
 DEFINE_INTERFACE_METHOD_1("ResetActiveQuery", std::vector<entity_id_t>, ICmpRangeManager, ResetActiveQuery, ICmpRangeManager::tag_t)
 DEFINE_INTERFACE_METHOD_3("SetEntityFlag", void, ICmpRangeManager, SetEntityFlag, entity_id_t, std::string, bool)
 DEFINE_INTERFACE_METHOD_1("GetEntityFlagMask", u8, ICmpRangeManager, GetEntityFlagMask, std::string)
 DEFINE_INTERFACE_METHOD_1("GetEntitiesByPlayer", std::vector<entity_id_t>, ICmpRangeManager, GetEntitiesByPlayer, player_id_t)
+DEFINE_INTERFACE_METHOD_0("GetAllPlayerEntities", std::vector<entity_id_t>, ICmpRangeManager, GetAllPlayerEntities)
 DEFINE_INTERFACE_METHOD_1("SetDebugOverlay", void, ICmpRangeManager, SetDebugOverlay, bool)
 DEFINE_INTERFACE_METHOD_1("ExploreAllTiles", void, ICmpRangeManager, ExploreAllTiles, player_id_t)
 DEFINE_INTERFACE_METHOD_0("ExploreTerritories", void, ICmpRangeManager, ExploreTerritories)
 DEFINE_INTERFACE_METHOD_2("SetLosRevealAll", void, ICmpRangeManager, SetLosRevealAll, player_id_t, bool)
 DEFINE_INTERFACE_METHOD_1("GetLosRevealAll", bool, ICmpRangeManager, GetLosRevealAll, player_id_t)
Index: source/simulation2/components/ICmpRangeManager.h
===================================================================
--- source/simulation2/components/ICmpRangeManager.h	(revision 16411)
+++ source/simulation2/components/ICmpRangeManager.h	(working copy)
@@ -177,18 +177,23 @@
 	 * @return list of entities matching the query, ordered by increasing distance from the source entity.
 	 */
 	virtual std::vector<entity_id_t> ResetActiveQuery(tag_t tag) = 0;
 
 	/**
-	 * Returns list of all entities for specific player.
+	 * Returns a list of all entities for specific player.
 	 * (This is on this interface because it shares a lot of the implementation.
 	 * Maybe it should be extended to be more like ExecuteQuery without
 	 * the range parameter.)
 	 */
 	virtual std::vector<entity_id_t> GetEntitiesByPlayer(player_id_t player) = 0;
 
 	/**
+	 * Returns a list of all entities for all players.
+	 */
+	virtual std::vector<entity_id_t> GetAllPlayerEntities() = 0;
+
+	/**
 	 * Toggle the rendering of debug info.
 	 */
 	virtual void SetDebugOverlay(bool enabled) = 0;
 
 	/**
Index: source/simulation2/helpers/Selection.cpp
===================================================================
--- source/simulation2/helpers/Selection.cpp	(revision 16411)
+++ source/simulation2/helpers/Selection.cpp	(working copy)
@@ -162,10 +162,37 @@
 	}
 
 	return hitEnts;
 }
 
+std::vector<entity_id_t> EntitySelection::PickAllPlayerEntitiesInRect(CSimulation2& simulation, const CCamera& camera, int sx0, int sy0, int sx1, int sy1, bool allowEditorSelectables)
+{
+	PROFILE2("PickAllPlayerEntitiesInRect");
+	// Make sure sx0 <= sx1, and sy0 <= sy1
+	if (sx0 > sx1)
+		std::swap(sx0, sx1);
+	if (sy0 > sy1)
+		std::swap(sy0, sy1);
+
+	CmpPtr<ICmpRangeManager> cmpRangeManager(simulation, SYSTEM_ENTITY);
+	ENSURE(cmpRangeManager);
+
+	std::vector<entity_id_t> hitEnts;
+
+	CComponentManager& componentManager = simulation.GetSimContext().GetComponentManager();
+
+	std::vector<entity_id_t> ents = cmpRangeManager->GetAllPlayerEntities();
+	for (std::vector<entity_id_t>::iterator it = ents.begin(); it != ents.end(); ++it)
+	{
+		CmpPtr<ICmpOwnership> cmpOwnership(simulation.GetSimContext(), *it);
+		if (CheckEntityVisibleAndInRect(componentManager.LookupEntityHandle(*it), cmpRangeManager, camera, sx0, sy0, sx1, sy1, cmpOwnership->GetOwner(), allowEditorSelectables))
+			hitEnts.push_back(*it);
+	}
+
+	return hitEnts;
+}
+
 std::vector<entity_id_t> EntitySelection::PickSimilarEntities(CSimulation2& simulation, const CCamera& camera, 
 	const std::string& templateName, player_id_t owner, bool includeOffScreen, bool matchRank,
 	bool allowEditorSelectables, bool allowFoundations)
 {
 	PROFILE2("PickSimilarEntities");
Index: source/simulation2/helpers/Selection.h
===================================================================
--- source/simulation2/helpers/Selection.h	(revision 16411)
+++ source/simulation2/helpers/Selection.h	(working copy)
@@ -63,10 +63,25 @@
  * @return unordered list of selected entities.
  */
 std::vector<entity_id_t> PickEntitiesInRect(CSimulation2& simulation, const CCamera& camera, int sx0, int sy0, int sx1, int sy1, player_id_t owner, bool allowEditorSelectables);
 
 /**
+ * Finds all selectable entities within the given screen coordinate rectangle,
+ * belonging to any player.
+ *
+ * @param camera use this view to convert screen to world coordinates.
+ * @param sx0,sy0,sx1,sy1 diagonally opposite corners of the rectangle in 2D screen coordinates.
+ * @param owner player whose entities we are selecting. Ownership is ignored if
+ *	INVALID_PLAYER is used.
+ * @param allowEditorSelectables if true, all entities with the ICmpSelectable interface
+ *	will be selected (including decorative actors), else only those selectable ingame.
+ *
+ * @return unordered list of selected entities.
+ */
+std::vector<entity_id_t> PickAllPlayerEntitiesInRect(CSimulation2& simulation, const CCamera& camera, int sx0, int sy0, int sx1, int sy1, bool allowEditorSelectables);
+
+/**
  * Finds all entities with the given entity template name, belonging to the given player.
  * 
  * @param camera use this view to convert screen to world coordinates.
  * @param templateName the name of the template to match, or the selection group name
  *	for similar matching.