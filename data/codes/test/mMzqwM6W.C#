*/ using script; using System; using System.Collections.Generic; using System.IO; using System.Reflection; using System.Text.RegularExpressions; using System.Xml; using UnityEngine; using UnityInjector; using UnityInjector.Attributes; namespace CM3D2.MaidVoicePitch.Plugin { // using static Helper; [PluginFilter("CM3D2x64"), PluginFilter("CM3D2x86"), PluginFilter("CM3D2VRx64"), PluginName("CM3D2 MaidVoicePitch"), PluginVersion("0.1.7.0")] public class MaidVoicePitch : PluginBase { public bool bEditScene = false; public bool bKagTagPropSetHooked = false; public Dictionary<WeakReference, Status> cache = null; public Dictionary<string, FaceScriptTemplate> faceScriptTemplates = null; delegate bool TagCallbackDelegate(KagTagSupport tag_data); delegate bool TagProcDelegate(string kagManagerTypeName, Type kagManagerType, BaseKagManager baseKagManager, KagTagSupport tag_data); public class Status { public bool bPropSetOff = false; public string faceScriptTemplateFilename = null; public float faceAnimeSpeed = 1.0f; public Status() { } public Status(bool b, string f, float faceAnimeSpeed) { bPropSetOff = b; faceScriptTemplateFilename = f; this.faceAnimeSpeed = faceAnimeSpeed; } } public void Awake() { UnityEngine.GameObject.DontDestroyOnLoad(this); FlushFaceScriptTemplatesCache(); FlushCache(); TestPropSet(); } public void OnLevelWasLoaded(int level) { bKagTagPropSetHooked = false; TestPropSet(); } public void Update() { // テンプレートキャッシュを消去して、再読み込みを促す if (Input.GetKey(KeyCode.F12)) { FlushFaceScriptTemplatesCache(); } if (CharacterMgr.EditModeLookHaveItem) { MaidsUpdate(true); // エディット画面にる場合、アップデートを行う } } public void LateUpdate() { MaidsUpdate(false); } void MaidsUpdate(bool bEditUpdate) { if (GameMain.Instance == null || GameMain.Instance.CharacterMgr == null) { return; } FlushCache(); CharacterMgr cm = GameMain.Instance.CharacterMgr; for (int i = 0, n = cm.GetStockMaidCount(); i < n; i++) { MaidUpdate(cm.GetStockMaid(i), bEditUpdate); } } void MaidUpdate(Maid maid, bool bEditUpdate) { if (maid == null) { return; } string freeComment = null; if (maid.Param != null && maid.Param.status != null && maid.Param.status.free_comment != null) { freeComment = maid.Param.status.free_comment; } if (freeComment == null) { return; } UpdateCache(maid, freeComment); // リップシンク(口パク)しない bool bLipsyncOff = freeComment.IndexOf("#LIPSYNC_OFF#") > -1; // 目と口の表情変化をやめる bool bHyoujouOff = freeComment.IndexOf("#HYOUJOU_OFF#") > -1; // 全ての顔変化をやめる bool bMuhyou = freeComment.IndexOf("#MUHYOU#") > -1; // 目を常時カメラに向ける bool bEyeToCam = freeComment.IndexOf("#EYETOCAM#") > -1; // 顔を常時カメラに向ける bool bHeadToCam = freeComment.IndexOf("#HEADTOCAM#") > -1; if (bLipsyncOff || bMuhyou) { Helper.SetInstanceField(typeof(Maid), maid, "m_bFoceKuchipakuSelfUpdateTime", true); } else { if (bEditUpdate) { Helper.SetInstanceField(typeof(Maid), maid, "m_bFoceKuchipakuSelfUpdateTime", false); } } if (bMuhyou) { Helper.SetInstanceField(typeof(Maid), maid, "MabatakiVal", 1f); } if (bHyoujouOff || bMuhyou) { maid.FaceAnime("", 0f, 0); } if (bEyeToCam) { if (maid.body0 != null) { maid.body0.boEyeToCam = true; } } if (bHeadToCam) { if (maid.body0 != null) { maid.body0.boHeadToCam = true; } } Pitch(maid, freeComment); Mabataki(maid, freeComment); WideSlider(maid, freeComment); EyeBall(maid, freeComment); TestMabatakiSpeed(maid, freeComment, bEditUpdate); TestPelvis(maid, freeComment); TestLipSync(maid, freeComment); } // キャッシュ状態更新 void FlushCache() { cache = new Dictionary<WeakReference, Status>(); } void FlushFaceScriptTemplatesCache() { faceScriptTemplates = new Dictionary<string, FaceScriptTemplate>(); } void UpdateCache(Maid maid, string freeComment) { // @PropSetを無視する bool bPropSetOff = freeComment.IndexOf("#PROPSET_OFF#") > -1 || freeComment.IndexOf("#TEST_PROPSET_OFF#") > -1; // テンプレート指定 string templateName = null; { Match m = Regex.Match(freeComment, @"#TEST_FACE_SCRIPT_TEMPLATE=([^#]*)#"); if (m.Groups.Count >= 2) { templateName = m.Groups[1].Value; } } float faceAnimeSpeed = 1.0f; { Match m = Regex.Match(freeComment, @"#TEST_FACE_ANIME_SPEED=(.*)#"); if (m.Groups.Count >= 2) { faceAnimeSpeed = Mathf.Clamp(Helper.FloatTryParse(m.Groups[1].Value), 0.01f, 100f); } } cache.Add(new WeakReference(maid, false), new Status(bPropSetOff, templateName, faceAnimeSpeed)); } Status GetStatusByName(string maidName) { foreach (var kv in cache) { var o = (Maid)kv.Key.Target; if (o != null && o.name == maidName) { return kv.Value; } } return null; } bool IsPropSetOff(string maidName) { Status s = GetStatusByName(maidName); if (s == null) { return false; } return s.bPropSetOff; } string GetFaceScriptTemplateFilename(string maidName) { Status s = GetStatusByName(maidName); if (s == null) { return null; } return s.faceScriptTemplateFilename; } FaceScriptTemplate GetFaceScriptTemplate(string maidName) { FaceScriptTemplate t = null; string fname = GetFaceScriptTemplateFilename(maidName); if (fname != null) { if (!faceScriptTemplates.TryGetValue(fname, out t)) { faceScriptTemplates[fname] = FaceScriptTemplate.Load(fname); return faceScriptTemplates[fname]; } } return t; } float GetFaceAnimeSpeed(string maidName) { Status s = GetStatusByName(maidName); if (s == null) { return 1f; } return s.faceAnimeSpeed; } // ピッチ変更 void Pitch(Maid maid, string freeComment) { if (maid.AudioMan == null || maid.AudioMan.audiosource == null || !maid.AudioMan.audiosource.isPlaying) { return; } Match m = Regex.Match(freeComment, @"#PITCH=([-+]?[0-9]*\.?[0-9]+)"); maid.AudioMan.audiosource.pitch = 1f + Helper.FloatTryParse(m.Groups[1].Value); } // まばたき制限 void Mabataki(Maid maid, string freeComment) { float mabatakiVal = (float)Helper.GetInstanceField(typeof(Maid), maid, "MabatakiVal"); Match m = Regex.Match(freeComment, @"#MABATAKI=([-+]?[0-9]*\.?[0-9]+)#"); if (m.Groups.Count >= 2) { float f = Mathf.Clamp01(1f - Helper.FloatTryParse(m.Groups[1].Value)); float mMin = Mathf.Asin(f); float mMax = (float)Math.PI - mMin; mMin = Mathf.Pow(mMin / (float)Math.PI, 0.5f); mMax = Mathf.Pow(mMax / (float)Math.PI, 0.5f); mabatakiVal = Mathf.Clamp(mabatakiVal, mMin, mMax); } // 旧まばたき (そのうち廃止) { Match mb = Regex.Match(freeComment, @"#MABATAKI=([-+]?[0-9]*\.?[0-9]+),([-+]?[0-9]*\.?[0-9]+)#"); if (mb.Groups.Count >= 3) { float mMin = Helper.FloatTryParse(mb.Groups[1].Value); float mMax = Helper.FloatTryParse(mb.Groups[2].Value); mabatakiVal = Mathf.Clamp(mabatakiVal, mMin, mMax); } } Helper.SetInstanceField(typeof(Maid), maid, "MabatakiVal", mabatakiVal); } // まばたき速度変更 void TestMabatakiSpeed(Maid maid, string freeComment, bool bEditUpdate) { Match m = Regex.Match(freeComment, @"#TEST_MABATAKI_SPEED=([-+]?[0-9]*\.?[0-9]+)#"); if (m.Groups.Count >= 2) { float mabatakiVal = (float)Helper.GetInstanceField(typeof(Maid), maid, "MabatakiVal"); if (mabatakiVal != 1f && mabatakiVal > 0.1f && !bEditUpdate) { float f = Mathf.Clamp(Helper.FloatTryParse(m.Groups[1].Value), 0f, 10f); mabatakiVal += Time.deltaTime * 2f; mabatakiVal -= Time.deltaTime * 2f * f; } Helper.SetInstanceField(typeof(Maid), maid, "MabatakiVal", mabatakiVal); } } // 瞳サイズ変更 void EyeBall(Maid maid, string freeComment) { TBody tbody = maid.body0; Match mEyeBall = Regex.Match(freeComment, @"#EYEBALL=([-+]?[0-9]*\.?[0-9]+),([-+]?[0-9]*\.?[0-9]+)#"); if (mEyeBall.Groups.Count >= 3 && tbody != null && tbody.trsEyeL != null && tbody.trsEyeR != null) { float w = Helper.FloatTryParse(mEyeBall.Groups[1].Value); float h = Helper.FloatTryParse(mEyeBall.Groups[2].Value); tbody.trsEyeL.localScale = new Vector3(1f, h, w); tbody.trsEyeR.localScale = new Vector3(1f, h, w); } } // スライダー範囲を拡大 void WideSlider(Maid maid, string freeComment) { bool bSlider = freeComment.IndexOf("#WIDESLIDER#") > -1 || freeComment.IndexOf("#TEST_WIDE_SLIDER#") > -1; if (!bSlider) { return; } float sliderScale = 20f; TBody tbody = maid.body0; if (tbody == null || tbody.bonemorph == null || tbody.bonemorph.bones == null) { return; } BoneMorph_ boneMorph_ = tbody.bonemorph; string[] PropNames = Helper.GetInstanceField(typeof(BoneMorph_), boneMorph_, "PropNames") as string[]; if (PropNames == null) { return; } for (int i = boneMorph_.bones.Count - 1; i >= 0; i--) { BoneMorphLocal boneMorphLocal = boneMorph_.bones[i]; Vector3 scl = new Vector3(1f, 1f, 1f); Vector3 pos = boneMorphLocal.pos; for (int j = 0; j < (int)PropNames.Length; j++) { float s = 1f; switch (j) { case 0: s = boneMorph_.SCALE_Kubi; break; case 1: s = boneMorph_.SCALE_Ude; break; case 2: s = boneMorph_.SCALE_Eye; break; case 3: s = boneMorph_.Postion_EyeX * (0.5f + boneMorph_.Postion_EyeY * 0.5f); break; case 4: s = boneMorph_.Postion_EyeY; break; case 5: s = boneMorph_.SCALE_HeadX; break; case 6: s = boneMorph_.SCALE_HeadY; break; case 7: s = boneMorph_.SCALE_DouPer; if (boneMorphLocal.Kahanshin == 0f) { s = 1f - s; } break; case 8: s = boneMorph_.SCALE_Sintyou; break; case 9: s = boneMorph_.SCALE_Koshi; break; case 10: s = boneMorph_.SCALE_Kata; break; case 11: s = boneMorph_.SCALE_West; break; default: s = 1f; break; } if ((boneMorphLocal.atr & 1 << (j & 31)) != 0) { Vector3 v0 = boneMorphLocal.vecs_min[j]; Vector3 v1 = boneMorphLocal.vecs_max[j]; Vector3 n0 = v0 * sliderScale - v1 * (sliderScale - 1f); Vector3 n1 = v1 * sliderScale - v0 * (sliderScale - 1f); float f = (s + sliderScale - 1f) * (1f / (sliderScale * 2.0f - 1f)); scl = Vector3.Scale(scl, Vector3.Lerp(n0, n1, f)); // scl = Vector3.Scale(scl, Vector3.Lerp(v0, v1, s)); } if ((boneMorphLocal.atr & 1 << (j + 16 & 31)) != 0) { Vector3 v0 = boneMorphLocal.vecs_min[j + 16]; Vector3 v1 = boneMorphLocal.vecs_max[j + 16]; Vector3 n0 = v0 * sliderScale - v1 * (sliderScale - 1f); Vector3 n1 = v1 * sliderScale - v0 * (sliderScale - 1f); float f = (s + sliderScale - 1f) * (1f / (sliderScale * 2.0f - 1f)); pos = Vector3.Scale(pos, Vector3.Lerp(n0, n1, f)); // pos = Vector3.Scale(pos, Vector3.Lerp(v0, v1, s)); } } if (boneMorphLocal.linkT == null) { continue; } if (boneMorphLocal.linkT.name != null && boneMorphLocal.linkT.name.Contains("Thigh_SCL_")) { boneMorph_.SnityouOutScale = Mathf.Pow(scl.x, 0.9f); } boneMorphLocal.linkT.localPosition = pos; boneMorphLocal.linkT.localScale = scl; } } // リップシンク強度指定 void TestLipSync(Maid maid, string freeComment) { Match m = Regex.Match(freeComment, @"#TEST_LIPSYNC=([-+]?[0-9]*\.?[0-9]+)#"); if (m.Groups.Count >= 2) { float f1 = Mathf.Clamp01(Helper.FloatTryParse(m.Groups[1].Value)); TBody tbody = maid.body0; if (tbody != null) { maid.VoicePara_1 = f1 * 0.5f; maid.VoicePara_2 = f1 * 0.074f; maid.VoicePara_3 = f1 * 0.5f; maid.VoicePara_4 = f1 * 0.05f; if (f1 < 0.01f) { maid.voice_ao_f2 = 0; } } } } // 骨盤部コリジョン指定 (空中に浮くので注意) void TestPelvis(Maid maid, string freeComment) { TBody tbody = maid.body0; Match m = Regex.Match(freeComment, @"#TEST_PELVIS=([-+]?[0-9]*\.?[0-9]+),([-+]?[0-9]*\.?[0-9]+),([-+]?[0-9]*\.?[0-9]+)#"); if (m.Groups.Count >= 4 && tbody != null && tbody.Pelvis != null) { float x = Helper.FloatTryParse(m.Groups[1].Value); float y = Helper.FloatTryParse(m.Groups[2].Value); float z = Helper.FloatTryParse(m.Groups[3].Value); tbody.Pelvis.localScale = new Vector3(x, y, z); } } // void TestPropSet() { if (!bKagTagPropSetHooked) { OverWriteTagCallback("propset", delegate (string typeName, Type type, BaseKagManager baseKagManager, KagTagSupport tag_data) { return TagPropSet(typeName, type, baseKagManager, tag_data); }); OverWriteTagCallback("faceblend", delegate (string typeName, Type type, BaseKagManager baseKagManager, KagTagSupport tag_data) { return TagFaceBlend(typeName, type, baseKagManager, tag_data); }); OverWriteTagCallback("face", delegate (string typeName, Type type, BaseKagManager baseKagManager, KagTagSupport tag_data) { return TagFace(typeName, type, baseKagManager, tag_data); }); bKagTagPropSetHooked = true; } } static void OverWriteTagCallback(string tagName, TagProcDelegate tagProcDelegate) { foreach (var kv in GameMain.Instance.ScriptMgr.kag_mot_dic) { BaseKagManager mgr = kv.Value; KagScript kag = mgr.kag; kag.RemoveTagCallBack(tagName); kag.AddTagCallBack(tagName, new KagScript.KagTagCallBack(delegate (KagTagSupport tag_data) { return tagProcDelegate("MotionKagManager", typeof(MotionKagManager), mgr, tag_data); })); } { BaseKagManager mgr = GameMain.Instance.ScriptMgr.adv_kag; KagScript kag = mgr.kag; kag.RemoveTagCallBack(tagName); kag.AddTagCallBack(tagName, new KagScript.KagTagCallBack(delegate (KagTagSupport tag_data) { return tagProcDelegate("ADVKagManager", typeof(ADVKagManager), mgr, tag_data); })); } { BaseKagManager mgr = GameMain.Instance.ScriptMgr.yotogi_kag; KagScript kag = mgr.kag; kag.RemoveTagCallBack(tagName); kag.AddTagCallBack(tagName, new KagScript.KagTagCallBack(delegate (KagTagSupport tag_data) { return tagProcDelegate("YotogiKagManager", typeof(YotogiKagManager), mgr, tag_data); })); } } public bool TagPropSet(string dbg, Type type, BaseKagManager baseKagManager, KagTagSupport tag_data) { baseKagManager.CheckAbsolutelyNecessaryTag(tag_data, "propset", new string[] { "category", "val" }); bool flag = tag_data.IsValid("temp"); string str = tag_data.GetTagProperty("category").AsString(); int num = tag_data.GetTagProperty("val").AsInteger(); Maid maidAndMan = GetMaidAndMan(tag_data); if (maidAndMan == null) { return false; } if (IsPropSetOff(maidAndMan.name)) { foreach (MPN mpn in Enum.GetValues(typeof(MPN))) { if (mpn.ToString("G") == str) { return false; } } } maidAndMan.SetProp(str, num, flag); return false; } public bool TagFaceBlend(string dbg, Type type, BaseKagManager baseKagManager, KagTagSupport tag_data) { baseKagManager.CheckAbsolutelyNecessaryTag(tag_data, "faceblend", new string[] { "name" }); string str = tag_data.GetTagProperty("name").AsString(); Maid maidAndMan = GetMaidAndMan(tag_data); if (maidAndMan == null) { return false; } if (str == "なし") { str = "無し"; } string str1 = ProcFaceBlendName(maidAndMan, str); maidAndMan.FaceBlend(str1); return false; } public bool TagFace(string dbg, Type type, BaseKagManager baseKagManager, KagTagSupport tag_data) { baseKagManager.CheckAbsolutelyNecessaryTag(tag_data, "face", new string[] { "name" }); string str0 = tag_data.GetTagProperty("name").AsString(); Maid maidAndMan = GetMaidAndMan(tag_data); if (maidAndMan == null) { return false; } string str = ProcFaceName(maidAndMan, str0); int num = 0; if (tag_data.IsValid("wait")) { num = tag_data.GetTagProperty("wait").AsInteger(); } WaitEventList waitEventList = GetWaitEventList(baseKagManager, "face"); if (num > 0) { waitEventList.Add(() => { if (maidAndMan != null && maidAndMan.body0 != null && maidAndMan.body0.isLoadedBody) { maidAndMan.FaceAnime(str, 1f / GetFaceAnimeSpeed(maidAndMan.name), 0); } }, num); } else { maidAndMan.FaceAnime(str, 1f / GetFaceAnimeSpeed(maidAndMan.name), 0); waitEventList.Clear(); } return false; } public string ProcFaceName(Maid maid, string faceName) { FaceScriptTemplate t = GetFaceScriptTemplate(maid.name); if (t == null) { return faceName; } return t.ProcFaceName(faceName); } public string ProcFaceBlendName(Maid maid, string faceBlendName) { FaceScriptTemplate t = GetFaceScriptTemplate(maid.name); if (t == null) { return faceBlendName; } return t.ProcFaceBlendName(faceBlendName); } static Maid GetMaidAndMan(KagTagSupport tag_data) { // class BaseKagManager protected static Maid MaidAndMan(KagTagSupport); MethodInfo methodInfo = typeof(BaseKagManager).GetMethod( "GetMaidAndMan", BindingFlags.NonPublic | BindingFlags.Static, null, new Type[] { typeof(KagTagSupport) }, null ); object obj = methodInfo.Invoke(null, new object[] { tag_data }); return obj as Maid; } static WaitEventList GetWaitEventList(BaseKagManager baseKagManager, string list_name) { // class BaseKagManager protected WaitEventList GetWaitEventList(string list_name) MethodInfo methodInfo = typeof(BaseKagManager).GetMethod( "GetWaitEventList", BindingFlags.NonPublic | BindingFlags.Instance, null, new Type[] { typeof(string) }, null ); object obj = methodInfo.Invoke(baseKagManager, new object[] { list_name }); return obj as WaitEventList; } } public class FaceScriptTemplate { public Dictionary<string, string> FaceBlends { get; set; } public Dictionary<string, string> Faces { get; set; } public FaceScriptTemplate() { FaceBlends = new Dictionary<string, string>(); Faces = new Dictionary<string, string>(); } public static FaceScriptTemplate Load(string fileName) { var result = new FaceScriptTemplate(); var xd = new XmlDocument(); try { xd.Load(fileName); foreach (XmlNode e in xd.SelectNodes("/facescripttemplate/faceblends/faceblend")) { result.FaceBlends[e.Attributes["key"].Value] = e.Attributes["value"].Value; } foreach (XmlNode e in xd.SelectNodes("/facescripttemplate/faces/face")) { result.Faces[e.Attributes["key"].Value] = e.Attributes["value"].Value; } } catch (Exception e) { Console.WriteLine("CM3D2.MaidVoicePitch.Plugin.FaceScriptTemplate.Load({0}) exception error -> " + e.Message); } return result; } public void Save(string fileName) { var xd = new XmlDocument(); xd.AppendChild(xd.CreateXmlDeclaration("1.0", "utf-8", null)); XmlNode n = xd.AppendChild(xd.CreateElement("facescripttemplate")); XmlNode b = n.AppendChild(xd.CreateElement("faceblends")); foreach (var kv in FaceBlends) { var c = b.AppendChild(xd.CreateElement("faceblend")); c.Attributes.Append(xd.CreateAttribute("key")).Value = kv.Key; c.Attributes.Append(xd.CreateAttribute("value")).Value = kv.Value; } XmlNode f = n.AppendChild(xd.CreateElement("faces")); foreach (var kv in Faces) { var c = f.AppendChild(xd.CreateElement("face")); c.Attributes.Append(xd.CreateAttribute("key")).Value = kv.Key; c.Attributes.Append(xd.CreateAttribute("value")).Value = kv.Value; } xd.Save(fileName); } public string ProcFaceName(string faceName) { string s; if (Faces.TryGetValue(faceName, out s)) { return s; } return faceName; } public string ProcFaceBlendName(string faceBlendName) { string s; if (FaceBlends.TryGetValue(faceBlendName, out s)) { return s; } return faceBlendName; } } public static class Helper { static StreamWriter logStreamWriter = null; static public DateTime now = DateTime.Now; static public void Log(string s) { if (logStreamWriter == null) { string filename = (@".\MaidVoicePitch_" + now.ToString("yyyyMMdd_HHmmss") + ".log"); logStreamWriter = new StreamWriter(filename, true); } logStreamWriter.Write(s); logStreamWriter.Flush(); } static public float FloatTryParse(string s) { float f = 0f; float.TryParse(s, out f); return f; } // http://stackoverflow.com/a/3303182/2132223 static public FieldInfo GetFieldInfo(Type type, string fieldName) { return type.GetField(fieldName, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static); } static public object GetInstanceField(Type type, object instance, string fieldName) { FieldInfo field = GetFieldInfo(type, fieldName); return field == null ? null : field.GetValue(instance); } static public void SetInstanceField(Type type, object instance, string fieldName, object val) { FieldInfo field = GetFieldInfo(type, fieldName); if (field != null) { field.SetValue(instance, val); } } } }